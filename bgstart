#! /bin/bash

#version 0.1   ,25.08.08 -- initial version from llstart
#version 0.1.1 ,27.08.10 -- fixed a bug in --submit
#version 0.1.2 ,15.09.10 -- fixed a bug in run_on_host
#version 0.1.3 ,03.12.10 -- --showdir will print scp like path
#version 0.1.4 ,07.12.10 -- added --queue option
#version 0.2.0 ,20.12.10 -- added default version check
#version 0.2.1 ,28.01.11 -- nomail is now default

#BEGIN DEFAULTS
#defaults options, uncomment and change only the lines you really need to change
#keep it in bash style, source must work on this file

############## QUEUE stuff #########
#command to submit a job
job_submit="llsubmit"
#command to get status
job_status="llq"
#commnd to cancel/delete a job
job_kill="llcancel"
#commnd to cancel/delete a job
job_info="llclass"
#extra options for submit
submit_opts=""
#name of the host, where to submit the jobs used by ssh/scp
#maybe create an sshalias
submit_host="genius"
#the real hostname ($HOSTNAME), when logon submit_host
real_submit_hostname="genius1"
#submit the script by default: yes/no
submit="yes"
#gateway to acces submit host
gateway="vip"
#default number of cpus to use
ncpus=128
#mode to run in: SMP/DUAL/VN
mode="SMP"
#network mode to run in: MESH/TORUS/PREFER_TORUS
netmode="PREFER_TORUS"
#default wall clock time
wall_time="24:00:00"
#overwrite the queue to be used this, empty = normal queue
specialq=""

########### MPI stuff ###############
#should mpirun (or equivalent) be added: yes/no
mpi_job="yes"
#the command to add for mpi jobs
mpirun_cmd="mpirun"


############# Script option ########
#default trunc name of the submit script
name="bg"
#template to add to the script name
template="_XXXXX"
#automatically naming of the script: yes/no
auto="no"
#add timing commands: yes/no
time="no"
#base dir to simlation space
#will be used after $HOME/$sim_base/$batchname
sim_base="sim"
#where to scp the needed files on the gateway
#it is evaluted later
scp_dir='\$HOME/BlueGene/$sim_base'
#file to create if jobs is finished
finish_file=""
#rebsumit the job until this file exists
resubmit_file=""
#file to source before running the command
extra_source=""
#default option if none are given on the command line
default_opts=""
#extra code to put in script after changing to the PWD and copy of files
# but before running the job
extra_begin_code=""
#extra code to put in script after running the job, but before copy back
extra_end_code=""

########### other options #####
#be quiet or not: yes/no
quiet="no"
#run in script mode: yes/no
scriptmode="no"
#wait for the jobs to finish: yes/no
wait="no"
#sec to wain in the --wait loop
sleeptime=900
#default email
#empty/none = no email, auto = leave it to queue where to send the mail
mail="none"
#header to show with --showjobs option
header="JOBS ON genius"
#shell to be used by default, none=bash
myshell="${SHELL##*/}"
#END DEFAULTS

#internal options not set in rcfile
#usage print out
usage="${0##*/} [OPTIONS] COMMAND [options]"
#internal for set command, empty for bash, but 'set' for tcsh
set=""
#was the connection already checked
checked_connection="no"
#user given script name
batchname=""
#user given log file name
logfile=""
#rc to read
rcfile="~/.${0##*/}rc"
#where to look for updates
branch=mpip
selfurl="http://job-tools.cj-overlay.googlecode.com/hg/bgstart?r=$branch"
verurl="http://www.mpip-mainz.mpg.de/~junghans/job-tools/version.php"

qecho() {
  [[ "$quiet" = "no" ]] && echo -e "$*"
}

die() {
  [ -z "$1" ] || echo -e "$*" >&2
  [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$real_submit_hostname" ]; then
    #we need bash -c here because $@ could contain $USER or so
    message="$(bash -c "$*" 2>&1)" || die "'$*' failed\nError message: $message"
  else
    [ -n "$gateway" ] && ssh="ssh $gateway" || ssh="ssh"
    if [ "$checked_connection" = "no" ]; then
      if [ -n "$gateway" ]; then
	ssh $gateway true || die "Heuristic connection check failed.
Change 'gateway' variable in your setting file ($rcfile), which is now set to '$gateway'
or make an ssh alias by adding the following block to your ~/.ssh/config:
####BEGIN COPY####
Host $gateway
	User <YOURNAME>
	Hostname vip.rzg.mpg.de
####END COPY####

To generate a setting file run:
   '${0##*/} --showdefaults > $rcfile'"
      fi
      ssh $gateway ssh $submit_host true || die "Heuristic connection check failed.
Change 'submit_host' variable in your setting file ($rcfile), which is now set to '$submit_host'.

To generate a setting file run:
   '${0##*/} --showdefaults > $rcfile'"
      checked_connection="yes"
    fi
    if [ -n "$gateway" ]; then
      message=$(ssh $gateway "ssh $submit_host '$@'" 2>&1) || die "ssh gateway "ssh $submit_host '$@'" failed\nError message: $message"
    else
      message=$(ssh $submit_host "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
    fi
  fi
  [ -z "$message" ] || echo -e "$message"
}

check_job() {
  local message
  [ -z "$1" ] && die "check_job: Missing argument"
  message=$(run_on_host "$job_status -u \$USER") || die
  if [ -z "$(echo -e "$message" | awk "(\$1~/$1/){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host NOT found"
    return 1
  elif [ -z "$(echo -e "$message" | awk "(\$1~/$1/)&&(\$5 !~ /N[QR]/){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host in error state"
    return 1
  else
    qecho "Job '$1' on $submit_host found"
    return 0
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  run_on_host "${job_kill} $1"
  return $?
}

stat_job() {
  run_on_host "$job_status -l $1"
  return $?
}

submit_job() {
  local message path
  [ -z "$1" ] && die "submit_job: missing argument"
  [ -f "$1" ] || die "Could not find $1"
  path="$(get_path_from_script $1)" || die
  message="$(run_on_host "cd $path; $job_submit $submit_opts $1")" || die
  qecho "$message"
}

print_jobids() {
  local message job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  message=$(run_on_host "$job_status -u \$USER -f %id %jn") || die
  for job_id in $(echo -e "$message" | awk "(\$2 ~ /${1:0:8}/){print \$1}"); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

cpunr_to_queuename() {
  local secs
  [ -z "$1" ] && die "cpunr_to_queuename: Missing argument"
  secs=$(walltime_to_sec $wall_time) || die
  [ $secs -gt 86400 ] && die "Wall time bigger than 24h is not possible"
  if [ -n "$specialq" ]; then
    echo "$specialq"
  elif [ $1 -eq 128 ]; then
    [ $secs -le 43200  ] || die "Wall time of 128cpu queue is max 12h!"
    [ $secs -le 1800 ] && echo "tiny_30m" || echo "tiny"
  elif [ $1 -eq 256 ]; then
    [ $secs -le 7200 ] && echo "small_120m" || echo "small"
  elif [ $1 -eq 512 ]; then
    echo "medium"
  elif [ $1 -eq 1024 ]; then
    echo "large"
  elif [ $1 -eq 2048 ]; then
    echo "huge"
  elif [ $1 -eq 4096 ]; then
    echo "xxl"
  else
    die "Do not know how to handle this Number of cpus '$1'"
  fi
}

walltime_to_sec() {
  local secs wall
  [ -z "$1" ] && die "walltime_to_sec: Missing argument"
  [ -z "${1/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
  wall="$1"
  secs=${wall##*:}
  wall=${wall%:??}
  secs=$(( $secs + 60*${wall##*:} ))
  wall=${wall%:??}
  secs=$(( $secs + 3600*${wall##*:} ))
  echo "$secs"
}

queue_info() {
  local queue
  if [ -n "$1" ]; then
    number_check "$1" "--queueinfo"
    queue="$(cpunr_to_queuename "$1")" || die
    run_on_host "$job_info $queue"
  else
    run_on_host "$job_info"
  fi
  return $?
}

get_version() {
  sed -ne 's/^#version[[:space:]]*\([^[:space:]]*\)[[:space:]]*,.*$/\1/p' $1 | sed -n '$p'
}

get_webversion() {
  local version
  if [ "$1" = "-q" ]; then
    version="$(wget -qO- "${selfurl}" | get_version)"
  else
    [ -z "$(type -p wget)" ] && die "wget not found"
    version="$(wget -qO- "${selfurl}" )" || die "self_update: wget fetch from $selfurl failed"
    version="$(echo -e "${version}" | get_version)"
    [ -z "${version}" ] && die "get_webversion: Could not fetch new version number"
  fi
  echo "${version}"
}

version_check() {
  [ -z "$(type -p wget)" ] && return 1
  [ "$(wget -q -O - $verurl?name=${0##*/}&i=${USER}%40$HOSTNAME 2>&1)" = "active" ] || return 1
  old_version="$(get_version $0)"
  [ "$1" = "-q" ] && new_version="$(get_webversion -q)" || new_version="$(get_webversion)"
  [ "$1" = "-q" ] || echo "Version of $selfurl is: $new_version"
  [ "$1" = "-q" ] || echo "Local Version: $old_version"
  expr "${old_version}" \< "${new_version}" > /dev/null
  return $?
}

self_update() {
  [ -z "$(type -p wget)" ] && die "wget not found"
  if version_check; then
    echo "I will try replace myself now with $selfurl (CTRL-C to stop)"
    sleep 5
    wget -O "${0}" "${selfurl}"
  else
    echo "No updated needed"
  fi
}

showhelp() {
 cat << eoh
A script to start a job on the cluster.
It builds a very simple submit script (see -p options) and
run it.

$usage

SCRIPT OPTIONS:
-n, --name NAME      Change trunc name of script
                     Default: $name
    --batch NAME     Change name of the submit script
                     Default:  \$(mktemp ${name}$template)
                     (Argument is NAME+TEMPLATE)
-l, --log NAME       Change name of the output file
                     Default: log_"batch"
    --template TEXT  Change template for mktemp
                     Default: $template
-a, --auto           Use first argument as name
    --script         Will use the argument as base scripts and concatenate them
                     (implies --nompi)
-e, --emptytemplate  Same as --template ""
-m, --mail NAME      send mail to NAME
                     default: '$mail' (use 'auto' for automatic)
-f, --finish NAME    Touches file NAME when succesfully finished
-t, --time           Adds a date command before and after the command
-p, --print          Only print the submit script (implies --nosubmit)
    --nosubmit       Do submit the script, only create it (useful with --submit)
    --submit   FILE  Submit the script FILE
-r, --resubmit FILE  Resub the script if exit status was 0 and FILE not exist
-w, --wait           Waits for the job to finish and copyback data if finished
                     Exit status from existence of FILE from --finish or --resubmit
    --sleeptime      Changes the sleeptime for --wait
                     Default: $sleeptime
    --simdir         Where to do the simulation
                     Default: $sim_base
                     So simulation will be done in \$HOME/$sim_base/batchname, (batchname from above)
                     (Replaced by \$PWD if you run ${0##*/} on $submit_host)
    --shell NAME     Change the shell to use, script will sources ~/.XXXrc
                     Default: $myshell
    --source FILE    Source this file before run the progam
    --needed FILES   Give the files needed to be copy to the scratch dir to
                     run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
    --cpback FILE    Copy back files from jobs which was start with BATCH

QUEUE OPTIONS:
-N, --NNNN           Number of cpus (also determines the queue together with walltime) 
                     Possible: 128|256|..|4096
                     Default: $ncpus
    --mode XXX       Change threading mode: SMP, DUAL or VN
                     Default: $mode
    --netmode XXX    Change network mode: MESH/TORUS/PREFER_TORUS 
                     Default: $netmode
    --nompi          This is NOT a mpi job, so do NOT add mpirun (or equivalent)
                     to the command line (for ncpus > 1) automatically
    --walltime TIME  Change wall clock time
                     (use 128cpus and 00:30:00 or 256cpus and 02:00:00 for express queue)
                     Default: $wall_time
    --queue  NAME    Overwrite the queue to be used with NAME
                     (also in the case of --queueinfo)


JOBS OPTIONS:
    --showjobs        Show my jobs running (on $submit_host)
    --alljobs         Show all jobs running (on $submit_host)
    --checkjob JOB_ID Return true if job is still running (useful with -f)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --pcheck PATTERN  Return true if at least one job matching a pattern is still running
                      PATTERN is search in the name column (useful with -f)
                      "while ${0##*/} -q --pcheck NAME; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --showdir  JOB_ID Show pwd of simulation
    --taillog  JOB_ID Same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with number JOB_ID
    --statjob  JOB_ID Show status of the job with number JOB_ID
    --pkill PATTERN   Kill all jobs matching a pattern
    --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
    --queueinfo [NR]  Show info about some queue [128|256|..|4096] or all queues
                      (maybe altered by --walltime)
    --header          Show info header

COMMON OPTIONS:
    --               End of options (if program starts with -)
-q, --quiet          Be quiet
    --rcfile FILE    Extra setting file with defaults to read
                     Default: read only $rcfile if exist
    --showdefaults   Show the default settings before reading $rcfile and the
                     file given by --rcfile, useful to create own rcfile with:
                     "${0##*/} --showdefaults > $rcfile"
-v, --version        Prints version
    --selfupdate     Do a self update from googlecode (EXPERIMENTAL)
-h, --help           Show this help message

Notes for usage of space on $submit_host:
------------------------
-The usage of the scratch space is complicated, use it with care!
-You may add the input files to copy to the scratch dir  with --needed
 or use "--needed '*'", if want to copy all files of the current dir.
-If the binary in not in your PATH, give the full path of binary.


Examples:
   ${0##*/} --32 -p sleep 30
   ${0##*/} --32 -p --nompi poe sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} --32 --needed topol.tpr mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"
   ${0##*/} --32 --source ~/myGromacs/GMXRC --resubmit confout.gro --needed topol.tpr  mdrun -append -cpi state.cpt -maxh 24
            (Note: -cpi is smart, the first time mdrun will start normal!)
   ${0##*/} --32 --needed '*' --resubmit confout.gro  mdrun -append -cpi state.cpt -maxh 23
            (Note: --needed '*' needs a separate dir for the simulation!)

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_logs() {
  local message path logfile
  [ -z "$2" ] && die "show_logs: Missing argument"
  message=$(run_on_host "$job_status -l $1") || die
  path="$(echo -e "$message" | awk '/Initial Working Dir:/{print $4}')"
  logfile="$(echo -e "$message" | awk '/Out:/{print $2}')"
  run_on_host "$2 ${path}/${logfile}"
  return $?
}

show_path() {
  local message path
  [ -z "$1" ] && die "show_path: Missing argument"
  message=$(run_on_host "$job_status -l $1") || die
  path="$(echo -e "$message" | awk '/Initial Working Dir:/{print $4}')"
  [[ -z "$path" ]] && die "show_path: Could not get path"
  if [ "${HOSTNAME}" != "$real_submit_hostname" ]; then
    echo "${gateway}:$path"
  else
    echo "$path"
  fi
  return 0
}

copy_back() {
  local path
  [ -z "$1" ] && die "copy_back: Missing argument"
  [ -f "$1" ] || die "copy_back: Could not found $1"
  if [ "${HOSTNAME}" != "$real_submit_hostname" ]; then
    path=$(get_path_from_script $1) || die
    echo Copying back data from $submit_host:$path/ to .
    scp -Cr $submit_host:$path/* . || \
      die "scp -Cr $submit_host:./$path/* . failed"
    return $?
  else
    echo "You are already on $real_submit_hostname, skipping copy back of files"
  fi
}

get_path_from_script(){
  local path
  [ -z "$1" ] && die "get_path_from_script: Missing argument"
  [ -f "$1" ] || die "get_path_from_script: Could not found"
  [ -z "$(grep -e "${0##*/}" $1)" ] && die "$1 seems NOT to be a '${0##*/}' script"
  path="$(awk '/^cd/{print $2;exit 0}' $1)"
  [ -z "$path" ] && die "get_path_from_script: found not grep path from $1"
  echo "$path"
}

################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done

if [ -f $rcfile ]; then
  source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
  qecho "I have source $rcfile"
fi

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  --rcfile )
   rcfile="$2"
   source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
   qecho "I have source $rcfile"
   shift 2;;
  --showdefaults )
   sed -ne '/^#BEGIN DEFAULTS/,/^#END DEFAULTS/p' $0 | sed -e '1d' -e '$d' -e '/^[^#]/s/^/#/'
   exit 0;;
  -[0-9] | --[0-9]* )
   ncpus=${1#-}
   ncpus=${ncpus#-}
   number_check "$ncpus" "$1"
   shift;;
  --mode )
   mode=" SMP DUAL VN "
   [ -n "${mode//* $2 *}" ] && die "Argument of --mode has to be one of:$mode"
   mode="$2"
   shift 2;;
  --netmode )
   netmode=" MESH TORUS PREFER_TORUS "
   [ -n "${netmode//* $2 *}" ] && die "Argument of --netmode has to be one of:$netmode"
   netmode="$2"
   shift 2;;
  -p | --print )
   batchname="/dev/stdout"
   submit="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpi_job="no"
   shift ;;
   --nosubmit | --norun)
   submit="no"
   shift ;;
   --submit)
   submit_job "$2"
   exit $? ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --simdir )
   sim_base="$2"
   shift 2;;
   --needed )
   filelist=$2
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -r | --resub | --resubmit)
   resubmit_file="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --queue )
   specialq="$2"
   shift 2;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2 ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun | --nompi)
   mpi_job="no"
   shift ;;
   --walltime )
   wall_time="$2"
   [ -z "${wall_time/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
   shift 2;;
   --showjobs )
   run_on_host "$job_status -f %id %p %jn %o %st %dq %dd %c %h -u \$USER"
   exit $?;;
   --alljobs )
   run_on_host "$job_status -f %id %p %jn %o %st %dq %dd %c %h"
   exit $?;;
   --cpback )
   copy_back $2
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --statjob )
   stat_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   queue_info $2
   exit $?;;
   --showdir )
   show_path "$2"
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tail -f"
   exit $?;;
  -v | --version)
   echo "${0##*/}, version $(get_version $0) ($branch branch) by C. Junghans"
   exit 0;;
  --selfupdate)
   self_update
   exit $?;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  --)
   shift
   break;;
  *)
   die "Unknown option '$1'";;
 esac
done

if version_check -q; then
  x=${0##*/}; x=${x//?/#}
  echo "##################################$x"
  echo "# Your version of ${0##*/} is obsolete ! #"
  echo "# Please run '${0##*/} --selfupdate'     #"
  echo "##################################$x"
  unset x
fi

if [ -z "$1" ]; then
  [ -z "${default_opts}" ] && die "Missing program name (try --help)"
  set -- ${default_opts}
fi

[[ $auto = "yes" ]] && name=${1##*/}

if [ -z "$batchname" ]; then
  #template contains no 'X'
  if [ -z "${template//[^X]}" ]; then
    batchname="${name}"
  elif [ -n "$(type -p mktemp)" ]; then
    batchname=$(mktemp -u ${name}${template}) || die "mktemp could not generate file"
  else
    echo No mktemp found >&2
    l=${template//[^X]}
    l=${#l}
    t2=${template}
    batchname=${0}
    while [ -f ${batchname} ]; do
      for ((i=0;i<$l;i++)); do
        t2=${t2/X/${RANDOM:0:1}}
      done
      batchname=${name}${t2}
    done
  fi
  touch ${batchname}
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "submit script: $batchname"
  qecho "logfile: $logfile"
fi

queue_name="$(cpunr_to_queuename $ncpus)" || die

cat <<EOF >> $batchname
#! /bin/bash
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using $($0 --version)
# @ shell = /bin/bash
# @ wall_clock_limit= $wall_time
# @ job_type = bluegene
# @ bg_size = $ncpus
# @ bg_connection = $netmode
# @ class = $queue_name
# @ error = $logfile
# @ output = $logfile
# @ job_name = $batchname
EOF

#To mail or not to mail
if [ -z "$mail" ] || [ "$mail" = "none" ]; then
  echo '# @ notification = never' >> $batchname
else
  echo '# @ notification = complete' >> $batchname
  [ "$mail" = "auto" ] || echo "# @ notify_user = $mail" >> $batchname
fi

cat <<EOF >> $batchname
# @ queue

EOF

if [ "${HOSTNAME}" = "$real_submit_hostname" ]; then
  #we are already on vip
  sim_dir=$PWD
else
  sim_dir="\$HOME/$sim_base/$batchname"
fi

if [ "$(run_on_host 'echo $SHELL')" != "/bin/bash" ]; then
  echo "Your shell of $submit_host is NOT /bin/bash -> I will guarantee for nothing, change your shell to bash or take the risk ;-)" >&2
else
  sh_source="[ -f ~/.bashrc ] && source ~/.bashrc"
fi

cat <<EOF >>$batchname

${sh_source}

cd $sim_dir
echo Hi, I am job \$JOB_ID on \$HOSTNAME in \$PWD

EOF
[ -n "$extra_source" ] && echo "source $extra_source" >> $batchname

if [ -n "${extra_begin_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra begin code
${extra_begin_code}
#END of extra begin code
EOF
fi

echo echo Starting simulation >> $batchname

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname
  done
  cmdline=""
elif [ "$mpi_job" = "no" ] || [ $ncpus -eq 1 ]; then
  cmdline="$*"
else
  exe="$1"
  shift
  [ -z "$1" ] && cmdline="$mpirun_cmd -mode $mode -exe $exe" || cmdline="$mpirun_cmd -mode $mode -exe $exe -args \"$*\""
fi

cat <<EOF >>$batchname
$cmdline
result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

if [ -n "${extra_end_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra end code
${extra_end_code}
#END of extra end code
EOF
fi

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ -n "$resubmit_file" ]; then
  [ -f "$resubmit_file" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $job_submit in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f '$resubmit_file' ] && $job_submit $sim_dir/$batchname" >> $batchname
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && [ -f $resubmit_file ] && touch $finish_file" >> $batchname
else
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && touch '$finish_file'" >> $batchname
fi

if [ "${HOSTNAME}" != "$real_submit_hostname" ]; then
    #we are not on vip
   if [ -z "$filelist" ]; then
     echo "Run a simulation on $submit_host from here with no needed files ?" >&2
     echo "I do NOT think this make sense, do it manually!" >&2
     die "to submit the script run: '${0##*/} --sbumit $batchname'"
   fi
   scp_dir=$(eval echo $scp_dir)
   message=$(ssh $gateway "test -d $scp_dir/$batchname || echo Good") || die
   [ "$message" = "Good" ] || die "$gateway:$scp_dir/$batchname exists"
   ssh $gateway "mkdir -p $scp_dir/$batchname" || die "mkdir failed"
   echo "Copying needed files to $gateway:$scp_dir/$batchname/"
   scp -Cr $filelist $batchname $extra_source $gateway:$scp_dir/$batchname/ || \
     die "scp of files failed"
fi

if [ "$submit" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && qecho "to submit the script run: '${0##*/} --submit $batchname'"
  exit 0
fi

submit_job $batchname

if [ "$wait" = "yes" ]; then
  sleep 10
  qecho "Waiting for $batchname to finish"
  quiet="yes"
  while pcheck_job $batchname; do
    sleep $sleeptime;
  done
  copy_back $batchname
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resubmit_file}" ]] && [[ ! -f "$resubmit_file" ]] && exit 1
  exit 0
fi
