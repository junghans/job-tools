#! /bin/bash

#version 0.1   ,02.09.09 -- initial version from qstart
#version 0.1.1 ,18.09.09 -- added header in script
#version 0.1.2 ,14.10.09 -- missing number check
#version 0.1.3 ,12.11.09 -- fixed a bug in option parsing
#version 0.1.4 ,12.11.09 -- 32 cpus is a long option now
#version 0.1.5, 24.11.09 -- added --showdir + better output in logfile
#version 0.1.6, 30.11.09 -- fixed bug in number parsing
#version 0.1.6, 07.12.09 -- fixed bug in resub (thx to manuel)
#version 0.2.0, 07.01.09 -- major reworked, nicer jobs status
#version 0.2.1, 08.01.09 -- added some useful messages + --walltime
#version 0.2.2, 11.01.10 -- added --source option + cmdline in script + ibm hacks
#version 0.2.3, 01.02.10 -- rm batchname, when crashing, resub warning
#version 0.2.4, 25.02.10 -- added --smt option
#version 0.3.0, 03.08.10 -- added some extra checks (thx to mara)
#version 0.4.0, 16.08.10 -- added rcoptions and merge with qstart
#version 0.4.1, 23.08.10 -- allow devel queue with 4,8,16 cpus
#version 0.4.2 ,24.08.10 -- added --selfupdate
#version 0.4.3 ,25.08.10 -- added --mode options
#version 0.4.4 ,27.08.10 -- fixed a bug in --submit
#version 0.4.5 ,14.09.10 -- fixed a bug iin cpunr_to_queuename

#BEGIN DEFAULTS
#defaults options, uncomment and change only the lines you really need to change
#keep it in bash style, source must work on this file

############## QUEUE stuff #########
#command to submit a job
job_submit="llsubmit"
#command to get status
job_status="llq"
#commnd to cancel/delete a job
job_kill="llcancel"
#commnd to cancel/delete a job
job_info="llclass"
#extra options for submit
submit_opts=""
#name of the host, where to submit the jobs used by ssh/scp
#maybe create an sshalias
submit_host="vip"
#the real hostname ($HOSTNAME), when logon submit_host
real_submit_hostname="vip001"
#submit the script by default: yes/no
submit="yes"
#default number of cpus to use
ncpus=32
#mode to run in: normal/smt (2 task per cpu)
mode="normal"
#default wall clock time
wall_time="24:00:00"

########### MPI stuff ###############
#should mpirun (or equivalent) be added: yes/no
mpi_job="yes"
#the command to add for mpi jobs
mpirun_cmd="/usr/bin/poe"


############# Script option ########
#default trunc name of the submit script
name="ll"
#template to add to the script name
template="_XXXXX"
#automatically naming of the script: yes/no
auto="no"
#add timing commands: yes/no
time="no"
#enable some extra ibm hacks: yes/no
ibm_hacks="no"
#base dir to simlation space
#will be used after $HOME/$sim_base/$batchname
sim_base="sim"
#file to create if jobs is finished
finish_file=""
#rebsumit the job until this file exists
resubmit_file=""
#file to source before running the command
extra_source=""
#default option if none are given on the command line
default_opts=""
#extra code to put in script after changing to the PWD and copy of files
# but before running the job
extra_begin_code=""
#extra code to put in script after running the job, but before copy back
extra_end_code=""

########### other options #####
#be quiet or not: yes/no
quiet="no"
#run in script mode: yes/no
scriptmode="no"
#wait for the jobs to finish: yes/no
wait="no"
#sec to wain in the --wait loop
sleeptime=900
#default email adress, empty = no email
mail="$USER@mpip-mainz.mpg.de"
#warn about wrong email if using llstart on real_submit_hostname
warn_mail="yes"
#header to show with --showjobs option
header="JOBS ON vip"
#shell to be used by default, none=bash
myshell="${SHELL##*/}"
#END DEFAULTS

#internal options not set in rcfile
#usage print out
usage="${0##*/} [OPTIONS] COMMAND [options]"
#internal for set command, empty for bash, but 'set' for tcsh
set=""
#was the connection already checked
checked_connection="no"
#user given script name
batchname=""
#user given log file name
logfile=""
#rc to read
rcfile="~/.${0##*/}rc"
#where to look for updates
selfurl="http://job-tools.cj-overlay.googlecode.com/hg/llstart"

qecho() {
  [[ "$quiet" = "no" ]] && echo -e "$*"
}

die() {
  [ -z "$1" ] || echo -e "$*" >&2
  [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$real_submit_hostname" ]; then
    ssh="bash -c"
  else
    if [ "$checked_connection" = "no" ]; then
      ssh $submit_host true || die "Heuristic connection check failed.
Change 'submit_host' variable in your setting file ($rcfile), which is now set to '$submit_host'
or make an ssh alias by adding the following block to your ~/.ssh/config:
####BEGIN COPY####
Host $submit_host
	User <YOURNAME>
	Hostname vip.rzg.mpg.de
####END COPY####

To generate a setting file run:
   '${0##*/} --showdefaults > $rcfile'"
      checked_connection="yes"
    fi
    ssh="ssh $submit_host"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  [ -z "$message" ] || echo -e "$message"
}

check_job() {
  local message
  [ -z "$1" ] && die "check_job: Missing argument"
  message=$(run_on_host "$job_status -u \$USER") || die
  if [ -z "$(echo -e "$message" | awk "(\$1~/$1/){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host NOT found"
    return 1
  elif [ -z "$(echo -e "$message" | awk "(\$1~/$1/)&&(\$5 !~ /N[QR]/){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host in error state"
    return 1
  else
    qecho "Job '$1' on $submit_host found"
    return 0
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  run_on_host "${job_kill} $1"
  return $?
}

stat_job() {
  run_on_host "$job_status -l $1"
  return $?
}

submit_job() {
  local message path
  [ -z "$1" ] && die "submit_job: missing argument"
  [ -f "$1" ] || die "Could not find $1"
  path="$(get_path_from_script $1)" || die
  message="$(run_on_host "cd $path; $job_submit $submit_opts $1")" || die
  qecho "$message"
}

print_jobids() {
  local message job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  message=$(run_on_host "$job_status -u \$USER -f %id %jn") || die
  for job_id in $(echo -e "$message" | awk "(\$2 ~ /${1:0:8}/){print \$1}"); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

cpunr_to_queuename() {
  local secs
  [ -z "$1" ] && die "cpunr_to_queuename: Missing argument"
  secs=$(walltime_to_sec $wall_time) || die
  [ $secs -gt 86400 ] && die "Wall time bigger than 24h is not possible"
  if [ $1 -eq 1 ]; then
    [ $secs -le 3600 ] || die "Wall time of single queue is max 1h!"
    [ "$mode" = "smt" ] && die "Single queue in smt mode is not possible - try -4"
    echo "single"
  elif [ $1 -eq 2 ]; then
    [ "$mode" = "normal" ] && die "Dual queue only possible in smt mode"
    [ $secs -le 900 ] && echo "develop_4p" || echo "small"
  elif [ $1 -eq 4 ] && [ "$mode" = "normal" ]; then
    [ $secs -le 900 ] && echo "develop_4p" || "small"
  elif [ $1 -eq 4 ] && [ "$mode" = "smt" ]; then
    [ $secs -le 900 ] && echo "develop_8p" || "small"
  elif [ $1 -eq 8 ] && [ "$mode" = "normal" ]; then
    [ $secs -le 900 ] && echo "develop_8p" || "small"
  elif [ $1 -eq 8 ] && [ "$mode" = "smt" ]; then
    [ $secs -le 900 ] && echo "develop_16p" || "small"
  elif [ $1 -eq 16 ] && [ "$mode" = "normal" ]; then
    [ $secs -le 900 ] && echo "develop_16p" || echo "small"
  elif [ $1 -eq 16 ] && [ "$mode" = "smt" ]; then
    [ $secs -le 1800 ] && echo "express" || echo "small"
  elif [ $1 -eq 32 ]; then
    [ $secs -le 1800 ] && echo "express" || echo "small"
  elif [ $1 -eq 64 ]; then
    echo "big"
  elif [ $1 -eq 128 ]; then
    echo "jumbo"
  elif [ $1 -eq 256 ]; then
    echo "dino"
  elif [ $1 -eq 512 ]; then
    echo "monster"
  elif [ $1 -eq 1024 ]; then
    echo "giant"
  elif [ $1 -eq 2048 ]; then
    echo "grant"
  elif [ $1 -eq 4096 ]; then
    echo "xxl"
  else
    die "Do not know how to handle this Number of cpus '$1'"
  fi
}

walltime_to_sec() {
  local secs wall
  [ -z "$1" ] && die "walltime_to_sec: Missing argument"
  [ -z "${1/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
  wall="$1"
  secs=${wall##*:}
  wall=${wall%:??}
  secs=$(( $secs + 60*${wall##*:} ))
  wall=${wall%:??}
  secs=$(( $secs + 3600*${wall##*:} ))
  echo "$secs"
}

queue_info() {
  local queue
  if [ -n "$1" ]; then
    number_check "$1" "--queueinfo"
    queue="$(cpunr_to_queuename "$1")" || die
    run_on_host "$job_info $queue"
  else
    run_on_host "$job_info"
  fi
  return $?
}

get_version() {
  sed -ne 's/^#version[[:space:]]*\([^[:space:]]*\)[[:space:]]*,.*$/\1/p' $1 | sed -n '$p'
}

self_update() {
  local new_version old_version
  [ -z "$(type -p wget)" ] && die "wget not found"
  new_version="$(wget -qO- "${selfurl}")" || die "self_update: wget fetch from $selfurl failed"
  new_version="$(echo -e "${new_version}" | get_version)"
  [ -z "${new_version}" ] && die "self_update: Could not fetch new version number"
  old_version="$(get_version $0)"
  echo "Version on googlecode is: $new_version"
  echo "Local Version: $old_version"
  new_version="$(echo "${new_version//[^0-9]}" | sed -e 's/^..$/&0/' -e 's/^...$/&0/')"
  old_version="$(echo "${old_version//[^0-9]}" | sed -e 's/^..$/&0/' -e 's/^...$/&0/')"
  if [ $new_version -gt $old_version ]; then
    echo "I will try replace myself($0) now with $selfurl in 5 secs (CTRL-C to stop)"
    sleep 5
    wget -O "${0}" "${selfurl}"
  else
    echo "No updated needed"
  fi
}

showhelp() {
 cat << eoh
A script to start a job on the cluster.
It builds a very simple submit script (see -p options) and
run it.

$usage

SCRIPT OPTIONS:
-n, --name NAME      Change trunc name of script
                     Default: $name
    --batch NAME     Change name of the submit script
                     Default:  \$(mktemp ${name}$template)
                     (Argument is NAME+TEMPLATE)
-l, --log NAME       Change name of the output file
                     Default: log_"batch"
    --template TEXT  Change template for mktemp
                     Default: $template
-a, --auto           Use first argument as name
    --script         Will use the argument as base scripts and concatenate them
                     (implies --nompi)
-e, --emptytemplate  Same as --template ""
-m, --mail NAME      send mail to NAME
                     default: '$mail'
-x, --nomail         will not use mail function
-f, --finish NAME    Touches file NAME when succesfully finished
-t, --time           Adds a date command before and after the command
-p, --print          Only print the submit script (implies --nosubmit)
    --nosubmit       Do submit the script, only create it (useful with --submit)
    --submit   FILE  Submit the script FILE
-r, --resubmit FILE  Resub the script if exit status was 0 and FILE not exist
-w, --wait           Waits for the job to finish and copyback data if finished
                     Exit status from existence of FILE from --finish or --resubmit
    --sleeptime      Changes the sleeptime for --wait
                     Default: $sleeptime
    --simdir         Where to do the simulation
                     Default: $sim_base
                     So simulation will be done in \$HOME/$sim_base/batchname, (batchname from above)
                     (Replaced by \$PWD if you run ${0##*/} on $submit_host)
    --shell NAME     Change the shell to use, script will sources ~/.XXXrc
                     Default: $myshell
    --source FILE    Source this file before run the progam
    --needed FILES   Give the files needed to be copy to the scratch dir to
                     run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
    --cpback FILE    Copy back files from jobs which was start with BATCH

QUEUE OPTIONS:
-N, --NNNN           Number of cpus (also determines the queue together with walltime) 
                     Possible: 1|4|8|16|32|64|128|..|4096
                     Default: $ncpus
    --mode XXX       Change threading mode: normal or smt (2 tasks per cpu)
                     Default: $mode
    --smt            Same as --mode smt
    --nompi          This is NOT a mpi job, so do NOT add mpirun (or equivalent)
                     to the command line (for ncpus > 1) automatically
    --walltime TIME  Change wall clock time
                     (use 32cpus and 00:30:00 for express queue,<=16 cpus and 00:15:00 for develop queue)
                     Default: $wall_time
    --ibm-hacks      Some extra ibm hack (EXPERIMENTAL)


JOBS OPTIONS:
    --showjobs        Show my jobs running (on $submit_host)
    --alljobs         Show all jobs running (on $submit_host)
    --checkjob JOB_ID Return true if job is still running (useful with -f)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --pcheck PATTERN  Return true if at least one job matching a pattern is still running
                      PATTERN is search in the name column (useful with -f)
                      "while ${0##*/} -q --pcheck NAME; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --showdir  JOB_ID Show pwd of simulation
    --taillog  JOB_ID Same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with number JOB_ID
    --statjob  JOB_ID Show status of the job with number JOB_ID
    --pkill PATTERN   Kill all jobs matching a pattern
    --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
    --queueinfo [NR]  Show info about some queue [1|4|8|16|32|64|128|..|4096] or all queues
    --header          Show info header

COMMON OPTIONS:
    --               End of options (if program starts with -)
-q, --quiet          Be quiet
    --rcfile FILE    Extra setting file with defaults to read
                     Default: read only $rcfile if exist
    --showdefaults   Show the default settings before reading $rcfile and the
                     file given by --rcfile, useful to create own rcfile with:
                     "${0##*/} --showdefaults > $rcfile"
-v, --version        Prints version
    --selfupdate     Do a self update from googlecode (EXPERIMENTAL)
-h, --help           Show this help message

Notes for usage of space on $submit_host:
------------------------
-The usage of the scratch space is complicated, use it with care!
-You may add the input files to copy to the scratch dir  with --needed
 or use "--needed '*'", if want to copy all files of the current dir.
-If the binary in not in your PATH, give the full path of binary.


Examples:
   ${0##*/} --32 -p sleep 30
   ${0##*/} --32 -p --nompi poe sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} --32 --needed topol.tpr mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"
   ${0##*/} --32 --source ~/myGromacs/GMXRC --resubmit confout.gro --needed topol.tpr  mdrun -append -cpi state.cpt -maxh 24
            (Note: -cpi is smart, the first time mdrun will start normal!)
   ${0##*/} --32 --needed '*' --resubmit confout.gro  mdrun -append -cpi state.cpt -maxh 23
            (Note: --needed '*' needs a separate dir for the simulation!)

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_logs() {
  local message path logfile
  [ -z "$2" ] && die "show_logs: Missing argument"
  message=$(run_on_host "$job_status -l $1") || die
  path="$(echo -e "$message" | awk '/Initial Working Dir:/{print $4}')"
  logfile="$(echo -e "$message" | awk '/Out:/{print $2}')"
  run_on_host "$2 ${path}/${logfile}"
  return $?
}

show_path() {
  local message path
  [ -z "$1" ] && die "show_path: Missing argument"
  message=$(run_on_host "$job_status -l $1") || die
  path="$(echo -e "$message" | awk '/Initial Working Dir:/{print $4}')"
  [[ -z "$path" ]] && die "show_path: Could not get path"
  echo "$path"
  return $?
}

copy_back() {
  local path
  [ -z "$1" ] && die "copy_back: Missing argument"
  [ -f "$1" ] || die "copy_back: Could not found $1"
  if [ "${HOSTNAME}" != "$real_submit_hostname" ]; then
    path=$(get_path_from_script $1) || die
    echo Copying back data from $submit_host:$path/ to .
    scp -Cr $submit_host:$path/* . || \
      die "scp -Cr $submit_host:./$path/* . failed"
    return $?
  else
    echo "You are already on $real_submit_hostname, skipping copy back of files"
  fi
}

get_path_from_script(){
  local path
  [ -z "$1" ] && die "get_path_from_script: Missing argument"
  [ -f "$1" ] || die "get_path_from_script: Could not found"
  [ -z "$(grep -e "${0##*/}" $1)" ] && die "$1 seems NOT to be a '${0##*/}' script"
  path="$(awk '/^cd/{print $2;exit 0}' $1)"
  [ -z "$path" ] && die "get_path_from_script: found not grep path from $1"
  echo "$path"
}

################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done

if [ -f $rcfile ]; then
  source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
  qecho "I have source $rcfile"
fi

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  --rcfile )
   rcfile="$2"
   source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
   qecho "I have source $rcfile"
   shift 2;;
  --showdefaults )
   sed -ne '/^#BEGIN DEFAULTS/,/^#END DEFAULTS/p' $0 | sed -e '1d' -e '$d' -e '/^[^#]/s/^/#/'
   exit 0;;
  -[0-9] | --[0-9]* )
   ncpus=${1#-}
   ncpus=${ncpus#-}
   number_check "$ncpus" "$1"
   shift;;
  --mode )
   mode=" smt normal "
   [ -n "${mode//* $2 *}" ] && die "Argument of --mode has to be one of:$mode"
   mode="$2"
   shift 2;;
  --smt )
   mode="smt"
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   submit="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpi_job="no"
   shift ;;
   --nosubmit | --norun)
   submit="no"
   shift ;;
   --submit)
   submit_job "$2"
   exit $? ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --simdir )
   sim_base="$2"
   shift 2;;
   --needed )
   filelist=$2
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -x | --nomail)
   mail=''
   shift ;;
   -r | --resub | --resubmit)
   resubmit_file="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --ibm-hacks)
   ibm_hacks="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2 ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun | --nompi)
   mpi_job="no"
   shift ;;
   --walltime )
   wall_time="$2"
   [ -z "${wall_time/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
   shift 2;;
   --showjobs )
   run_on_host "$job_status -f %id %p %jn %o %st %dq %dd %c %h -u \$USER"
   exit $?;;
   --alljobs )
   run_on_host "$job_status -f %id %p %jn %o %st %dq %dd %c %h"
   exit $?;;
   --cpback )
   copy_back $2
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --statjob )
   stat_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   queue_info $2
   exit $?;;
   --showdir )
   show_path "$2"
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tail -f"
   exit $?;;
  -v | --version)
   echo ${0##*/}, version $(get_version $0) by C. Junghans
   exit 0;;
  --selfupdate)
   self_update
   exit $?;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  --)
   shift
   break;;
  *)
   die "Unknown option '$1'";;
 esac
done

if [ -z "$1" ]; then
  [ -z "${default_opts}" ] && die "Missing program name (try --help)"
  set -- ${default_opts}
fi

[[ $auto = "yes" ]] && name=${1##*/}

if [ -z "$batchname" ]; then
  #template contains no 'X'
  if [ -z "${template//[^X]}" ]; then
    batchname="${name}"
  elif [ -n "$(type -p mktemp)" ]; then
    batchname=$(mktemp ${name}${template}) || die "mktemp could not generate file"
  else
    echo No mktemp found >&2
    l=${template//[^X]}
    l=${#l}
    t2=${template}
    for ((i=0;i<$l;i++)); do
      t2=${t2/X/${RANDOM:0:1}}
    done
    batchname=${name}${t2}
  fi
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "submit script: $batchname"
  qecho "logfile: $logfile"
fi

queue_name="$(cpunr_to_queuename $ncpus)" || die

if [ $ncpus -lt 32 ]; then
  nnodes=1
  [ "$mode" = "smt" ] && ncpus=$(($ncpus * 2))
  shared="shared"
  cpu_binding=""
else
  nnodes=$(($ncpus/32))
  [ "$mode" = "smt" ] && ncpus=64 || ncpus=32
  shared="not_shared"
  cpu_binding="ConsumableCpus(1)"
fi

cat <<EOF >> $batchname
#! /bin/bash
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using $($0 --version)
# @ shell = /bin/bash
# @ wall_clock_limit= $wall_time
# @ job_type = parallel
# @ node_usage = $shared
# @ tasks_per_node = $ncpus
# @ network.MPI = sn_all,$shared,us
# @ task_affinity = core(1)
# @ resources = ${cpu_binding}ConsumableMemory(1600 mb)
# @ node = $nnodes
# @ class = $queue_name
# @ error = $logfile
# @ output = $logfile
# @ job_name = $batchname
EOF

#To mail or not to mail
if [ -z "$mail" ]; then
  echo '# @ notification = never' >> $batchname
else
  echo '# @ notification = complete' >> $batchname
  echo "# @ notify_user = $mail" >> $batchname
  if [ "$warn_mail" = "yes" ] && [ "${HOSTNAME}" = "$real_submit_hostname" ]; then
    echo "# Check if '$mail' is  really your email !!!"
    echo "# if it is correct, change 'warn_mail' variable in your setting file ($rcfile) to no"
    echo "# if it is not correct, change 'mail' in $rcfile to the right adress or"
    echo "# add --nomail option"
    echo "# To generate a setting file run:"
    echo "#    '${0##*/} --showdefaults > $rcfile'"
    sleep 10
  fi
fi

cat <<EOF >> $batchname
# @ queue

export MP_EUILIB=us
export MP_EUIDEVICE=sn_all
export MP_SHARED_MEMORY=yes
export MEMORY_AFFINITY=MCM
#export MP_SINGLE_THREAD=yes
#export XLSMPOPTS parthds=1
#export OMP_NUM_THREADS=1

EOF

[ "$ibm_hacks" = "yes" ] && cat <<EOF >> $batchname
#BEGIN IBM HACKS, maybe unsupported or slower...
export MP_USE_BULK_XFER=no # yes for more than one node
export MP_BULK_MIN_MSG_SIZE=128k # also test 64k
export MP_EAGER_LIMIT=64 # also try 32k
export MP_BUFFER_MEM=64M,256M
export MP_RFIFO_SIZE=4194304    # also try 8M and 16M

export LAPI_DEBUG_QP_NOTIFICATION=no
export LAPI_DEBUG_ENABLE_AFFINTY=YES
export LAPI_DEBUG_STRIPE_SEND_FLIP=4
export LAPI_DEBUG_SLOT_ATT_THRESH=512000
export LAPI_DEBUG_ENABLE_RDMA_AFFINITY=YES # also try NO
#END IBM HACKS

EOF

if [ "${HOSTNAME}" = "$real_submit_hostname" ]; then
  #we are already on vip
  sim_dir=$PWD
else
  sim_dir="\$HOME/$sim_base/$batchname"
fi

if [ "$(run_on_host 'echo $SHELL')" != "/bin/bash" ]; then
  echo "Your shell of $submit_host is NOT /bin/bash -> I will guarantee for nothing, change your shell to bash or take the risk ;-)" >&2
else
  sh_source="[ -f ~/.bashrc ] && source ~/.bashrc"
fi

cat <<EOF >>$batchname

${sh_source}

cd $sim_dir
echo Hi, I am job \$JOB_ID on \$HOSTNAME in \$PWD

EOF
[ -n "$extra_source" ] && echo "source $extra_source" >> $batchname

if [ -n "${extra_begin_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra begin code
${extra_begin_code}
#END of extra begin code
EOF
fi

echo echo Starting simulation >> $batchname

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname
  done
  cmdline=""
elif [ "$mpi_job" = "no" ] || [ $ncpus -eq 1 ]; then
  cmdline="$*"
else
  cmdline="$mpirun_cmd $*"
fi

cat <<EOF >>$batchname
$cmdline
result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

if [ -n "${extra_end_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra end code
${extra_end_code}
#END of extra end code
EOF
fi

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ -n "$resubmit_file" ]; then
  [ -f "$resubmit_file" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $job_submit in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f '$resubmit_file' ] && $job_submit $sim_dir/$batchname" >> $batchname
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && [ -f $resubmit_file ] && touch $finish_file" >> $batchname
else
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && touch '$finish_file'" >> $batchname
fi

if [ "${HOSTNAME}" != "$real_submit_hostname" ]; then
    #we are not on vip
   if [ -z "$filelist" ]; then
     echo "Run a simulation on $submit_host from here with no needed files ?" >&2
     echo "I do NOT think this make sense, do it manually!" >&2
     die "to submit the script run: '${0##*/} --submit $batchname'"
   fi
   message=$(run_on_host "test -d \$HOME/$sim_base/$batchname || echo Good") || die
   [ "$message" = "Good" ] || die "$submit_host:\$HOME/$sim_base/$batchname exists"
   run_on_host "mkdir -p \$HOME/$sim_base/$batchname" || die "mkdir failed"
   echo Copying needed files to $submit_host:./$sim_base/$batchname/
   scp -Cr $filelist $batchname $extra_source $submit_host:./$sim_base/$batchname/ || \
     die "scp -Cr $filelist $batchname $submit_host:./$sim_base/$batchname/ failed"
fi

if [ "$submit" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && qecho "to submit the script run: '${0##*/} --submit $batchname'"
  exit 0
fi

submit_job $batchname

if [ "$wait" = "yes" ]; then
  sleep 10
  qecho "Waiting for $batchname to finish"
  quiet="yes"
  while pcheck_job $batchname; do
    sleep $sleeptime;
  done
  copy_back $batchname
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resubmit_file}" ]] && [[ ! -f "$resubmit_file" ]] && exit 1
  exit 0
fi
