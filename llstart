#! /bin/bash

#version 0.1   ,02.09.09 -- initial version from qstart
#version 0.1.1 ,18.09.09 -- added header in script
#version 0.1.2 ,14.10.09 -- missing number check
#version 0.1.3 ,12.11.09 -- fixed a bug in option parsing
#version 0.1.4 ,12.11.09 -- 32 cpus is a long option now
#version 0.1.5, 24.11.09 -- added --showdir + better output in logfile
#version 0.1.6, 30.11.09 -- fixed bug in number parsing
#version 0.1.6, 07.12.09 -- fixed bug in resub (thx to manuel)
#version 0.2.0, 07.01.09 -- major reworked, nicer jobs status
#version 0.2.1, 08.01.09 -- added some useful messages + --walltime
#version 0.2.2, 11.01.10 -- added --source option + cmdline in script + ibm hacks
#version 0.2.3, 01.02.10 -- rm batchname, when crashing, resub warning

#defaults
usage="${0##*/} [OPTIONS] COMMAND [options]"
job_submit="llsubmit"
job_status="llq"
job_kill="llcancel"
job_info="llclass"
mpirun="yes"
mpirun_cmd="/usr/bin/poe"
runhost="vip"
real_runhost="vip001"
ncpus=32
wall_time="24:00:00"
name="ll"
quiet="no"
auto="no"
run="yes"
batchname=""
logfile=""
finish_file=""
time="no"
template="_XXXXX"
mail="$USER@mpip-mainz.mpg.de"
header="JOBS ON vip"
sim_base="sim"
sim_dir=""
resub=""
myshell="${SHELL##*/}"
wait="no"
sleeptime=900
scriptmode="no"
extra_source=""
ibm_hacks="no"

qecho() {
  [[ "$quiet" = "no" ]] && echo "$*"
}

die() {
  echo -e "$*" >&2
  [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ "$1" = "--show" ] && { shift;ssh="echo "; }
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$runhost" ]; then
    ssh="${ssh}bash -c"
  else
    ssh="${ssh}ssh $runhost"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  [ -z "$message" ] || echo -e "$message"
}

check_job() {
  local message
  [ -z "$1" ] && die "check_job: Missing argument"
  message=$(run_on_host "$job_status -u \$USER") || die
  if [ -z "$(echo -e "$message" | awk "(\$1~/$1/){print \$0}")" ]; then
    qecho "Job '$1' on $runhost NOT found"
    return 1
  elif [ -z "$(echo -e "$message" | awk "(\$1~/$1/)&&(\$5 !~ /N[QR]/){print \$0}")" ]; then
    qecho "Job '$1' on $runhost in error state"
    return 1
  else
    qecho "Job '$1' on $runhost found"
    return 0
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  run_on_host "${job_kill} $1"
  return $?
}

print_jobids() {
  local message job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  message=$(run_on_host "$job_status -u \$USER -f %id %jn") || die
  for job_id in $(echo -e "$message" | awk "(\$2 ~ /${1:0:8}/){print \$1}"); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

cpunr_to_queuename(){
  [ -z "$1" ] && die "cpunr_to_queuename: Missing argument"
  if [ $1 -eq 32 ]; then
    echo "small"
  elif [ $1 -eq 64 ]; then
    echo "big"
  elif [ $1 -eq 128 ]; then
    echo "jumbo"
  elif [ $1 -eq 256 ]; then
    echo "dino"
  elif [ $1 -eq 512 ]; then
    echo "monster"
  elif [ $1 -eq 1024 ]; then
    echo "giant"
  elif [ $1 -eq 2048 ]; then
    echo "grant"
  elif [ $1 -eq 4096 ]; then
    echo "xxl"
  else
    echo ""
  fi
}

queue_info() {
  queue="$(cpunr_to_queuename $1)"
  run_on_host "$job_info $queue"
  return $?
}

showhelp() {
 cat << eoh
A script to start a job on the cluster.
It builds a very simple qsub script (see -p options) and
run it.

$usage

SCRIPT OPTIONS:
-n, --name NAME      Change global name of script
                     Default: $name
    --batch NAME     Change name of the qsub script
                     Default:  \$(mktemp ${name}$template)
                     (Argument is NAME+TEMPLATE)
-l, --log NAME       Change name of the output file
                     Default: log_"batchname"
    --template TEXT  Change template for mktemp
                     Default: $template
-a, --auto           Use first argument as global name
    --script         Will use the argument as base scripts and concatenate them
                     (implies --nompirun)
-e, --emptytemplate  Same as --template ""
-m, --mail NAME      send mail to NAME
                     default: '$mail'
-x, --nomail         will not use mail function
-f, --finish NAME    Create a file NAME when succesfully finished
                     Usefull with --checkjob and "[[ -f NAME ]] || exit 1"
-t, --time           Adds a date command before and after the command
-p, --print          Only print the qsub script (implies --norun)
    --norun          Do NOT run the qsub script in the end
-r, --resub FILE     Resub the script if exit status was 0 and FILE not exist
-w, --wait           Waits for the job to finish and copyback data
                     Exit status from existence of FILE from --finish or --resub
    --sleeptime      Changes the sleeptime for --wait
                     Default: $sleeptime
    --simdir         Where to do the simulation
                     Default: $sim_base
		     So simulation will be done in \$HOME/$sim_base/\$(mktemp ${name}$template)
		     (Replaced by \$PWD if you run ${0##*/} on $runhost)
    --shell NAME     Change the shell to use, script will sources ~/.XXXrc
                     Default: $myshell
    --source FILE    Source this file before run the progam
    --needed FILES   Give the files needed to be copy to the scratch dir to
                     run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
    --cpback BATCH   Copy back files from jobs which was start with BATCH

MPI OPTIONS:
-N, --NNNN           Number of cpus (also determines the queue)
                     Default: $ncpus
    --nompirun       Do NOT add mpirun automatically to the command line for ncpus > 1
    --walltime TIME  Change wall clock time (try 00:30:00 for express queue)
                     Default: $wall_time
    --ibm-hacks      Some extra ibm hack (EXPERIMENTAL)


JOBS OPTIONS:
    --showjobs        Show jobs running (on $runhost)
    --checkjob JOB_ID Return true if job is still running (useful with --f)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --pcheck PATTERN  Return true if at least one job matching a pattern is still running
                      PATTERN is search in the simname (useful with --f)
                      "while ${0##*/} -q --checkjob NAME; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --showdir  JOB_ID Show pwd of simulation
    --taillog  JOB_ID Same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with NUMBER
    --pkill PATTERN   Kill all jobs matching a pattern
    --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
    --queueinfo NR    Show info about some queue [32|64|128|..|4096]
    --header          Show info header

COMMON OPTIONS:
-q, --quiet          Be quiet
-v, --version        Prints version
-h, --help           Show this help message

Notes for scratch space :
------------------------
-The usage of the scratch space is still at the beginning of testing,
 use it with care!
-You may add the files to copy there with --needed or use "--needed '*'",
 if your job has a separate dir.
-Give the full path of binary or add itself to --needed and use "./", if
 it is not in your PATH variable.
-Remember to subtract the time needed to copy the files !

Examples:
   ${0##*/} --32 -p sleep 30
   ${0##*/} -8p --nompirun poe sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} --32 --needed topol.tpr mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"
   ${0##*/} --32 --resub confout.gro --needed topol.tpr  mdrun -append -cpi state.cpt -maxh 36
            (Note: -cpi is smart, the first time mdrun will start normal!)
   ${0##*/} --32 --needed '*' --resub confout.gro  mdrun -append -cpi state.cpt -maxh 35
            (Note: --needed '*' needs a separate dir for the simulation!)

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_jobs() {
  run_on_host "$job_status -f %id %p %jn %o %st %dq %dd %c %h -u \$USER"
  return $?
}

show_logs() {
  local message path logfile
  [ -z "$2" ] && die "show_logs: Missing argument"
  message=$(run_on_host "$job_status -l $1") || die
  path="$(echo -e "$message" | awk '/Initial Working Dir:/{print $4}')"
  logfile="$(echo -e "$message" | awk '/Out:/{print $2}')"
  run_on_host "$2 ${path}/${logfile}"
  return $?
}

show_path() {
  local message path
  [ -z "$1" ] && die "show_path: Missing argument"
  message=$(run_on_host "$job_status -l $1") || die
  path="$(echo -e "$message" | awk '/Initial Working Dir:/{print $4}')"
  [[ -z "$path" ]] && die "show_path: Could not get path"
  echo "$path"
  return $?
}

copy_back() {
  local path
  [ -z "$1" ] && die "copy_back: Missing argument"
  [ -f "$1" ] || die "$1 not found"
  [ -z "$(grep llstart $1)" ] && die "$1 seems NOT to be a llstart script"
  path="$(awk '/^cd/{print $2}' $1)"
  echo Copying back data from $runhost:$path/ to .
  scp -Cr $runhost:$path/* . || \
    die "scp -Cr $runhost:./$path/* . failed"
  return $?
}
################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done
while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  -[0-9] | --[0-9]* )
   ncpus=${1#-}
   ncpus=${ncpus#-}
   number_check "$ncpus" "$1"
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   run="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpirun="no"
   shift ;;
   --norun )
   run="no"
   shift ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --simdir )
   sim_base="$2"
   shift 2;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -x | --nomail)
   mail=''
   shift ;;
   -r | --resub)
   resub="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --ibm-hacks)
   ibm_hacks="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   if [ "$myshell" = "none"] || [ "$myshell" = "bash" ]; then
     :
   else
     echo We only support bash so far \;-\)
     exit 1
   fi
   shift 2 ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun )
   mpirun="no"
   shift ;;
   --walltime )
   wall_time="$2"
   [ -z "${wall_time/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
   shift 2;;
   --showdir )
   show_path $2
   exit $?;;
   --showjobs )
   show_jobs
   exit $?;;
   --cpback )
   copy_back $2
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   number_check "$2" "--queueinfo"
   queue_info $2
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tail -f"
   exit $?;;
  -v | --version)
   echo ${0##*/}, $(sed -ne 's/^#\(version.*\) -- .*$/\1/p' $0 | sed -n '$p') by C. Junghans
   exit 0;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  *)
   echo "Unknown option '$1'" >&2
   exit 1;;
  --)
   shift
   break;;
 esac
done

[ -z "$1" ] && die "Missing program name (try --help)"

[[ $auto = "yes" ]] && name=${1##*/}


if [ -z "$batchname" ]; then
  if [ -n $(type -p mktemp) ]; then
    batchname=$(mktemp ${name}${template}) || { echo mktemp could not generate file >&2; exit 1; }
  else
    echo No mktemp found >&2
    batchname=$name
  fi
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho llsubscript: $batchname
  qecho logfile: $logfile
fi

if [ "${HOSTNAME}" = "$real_runhost" ]; then
  #we are already on vip
  sim_dir=$PWD
else
  sim_dir="\$HOME/$sim_base/$batchname"
fi

queue_name="$(cpunr_to_queuename $ncpus)"
[ -z "$queue_name" ] && die "Do not know how to handle this Number of cpus '$nrcpus'"

nnodes=$(($ncpus/32))

cat <<EOF >> $batchname
#! /bin/bash
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using $($0 --version)
# @ shell = /bin/bash
# @ wall_clock_limit= $wall_time
# @ job_type = parallel
# @ node_usage= not_shared
# @ tasks_per_node = 32
# @ network.MPI = sn_all,not_shared,us
# @ task_affinity = core(1)
# @ resources = ConsumableMemory(1600 mb)
# @ node = $nnodes
# @ class = $queue_name
# @ error = $logfile
# @ output = $logfile
# @ job_name = $batchname
EOF


if [ -z "$mail" ]; then
  echo '# @ notification = never' >> $batchname
else
  echo '# @ notification = complete' >> $batchname
  echo "# @ notify_user = $mail" >> $batchname
fi
cat <<EOF >> $batchname
# @ queue

export MP_EUILIB=us
export MP_EUIDEVICE=sn_all
export MP_SHARED_MEMORY=yes
export MEMORY_AFFINITY=MCM
#export MP_SINGLE_THREAD=yes
#export XLSMPOPTS parthds=1
#export OMP_NUM_THREADS=1

EOF

[ "$ibm_hacks" = "yes" ] && cat <<EOF >> $batchname
#BEGIN IBM HACKS, maybe unsupported or slower...
export MP_USE_BULK_XFER=no # yes for more than one node
export MP_BULK_MIN_MSG_SIZE=128k # also test 64k
export MP_EAGER_LIMIT=64 # also try 32k
export MP_BUFFER_MEM=64M,256M
export MP_RFIFO_SIZE=4194304    # also try 8M and 16M

export LAPI_DEBUG_QP_NOTIFICATION=no
export LAPI_DEBUG_ENABLE_AFFINTY=YES
export LAPI_DEBUG_STRIPE_SEND_FLIP=4
export LAPI_DEBUG_SLOT_ATT_THRESH=512000
export LAPI_DEBUG_ENABLE_RDMA_AFFINITY=YES # also try NO
#END IBM HACKS

EOF
[[ "$myshell" = "bash" ]] && echo "[ -f ~/.bashrc ] && source ~/.bashrc" >> $batchname

cat <<EOF >>$batchname

cd $sim_dir
echo I am job \$JOB_ID on \$HOSTNAME in \$PWD
echo Starting simulation
EOF
[ -n "$extra_source" ] && echo "source $extra_source" >> $batchname
[[ "$time" = "yes" ]] && echo date >> $batchname

if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname
  done
elif [ "$mpirun" = "no" ] || [ $ncpus -eq 1 ]; then
  cmdline="$*"
else
  cmdline="$mpirun_cmd $*"
fi

cat <<EOF >>$batchname
$cmdline
result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ -n "$resub" ]; then
  [ -f "$resub" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $job_submit in next line will be wrong !!! >&2
  fi
  echo "[[ \$result -eq 0 ]] && [[ ! -f $resub ]] && { $job_submit $sim_dir/$batchname; exit 0; }" >> $batchname
fi
[[ -z "$finish_file" ]] || echo "[[ \$result -eq 0 ]] && touch $finish_file" >> $batchname

if [ "${HOSTNAME}" != "$real_runhost" ]; then
    #we are not on vip
   if [ -z "$filelist" ]; then
     echo "Run a simulation on $runhost from here with no needed files ?" >&2
     echo "I do NOT think this make sense, do it manually!" >&2
     run_on_host --show "cd $sim_dir;$job_submit $batchname"
     exit 1
   fi
   message=$(run_on_host "[ -d \$HOME/$sim_base/$batchname ] || echo Good") || die
   [ "$message" = "Good" ] || die "$runhost:\$HOME/$sim_base/$batchname exists"
   run_on_host "mkdir -p \$HOME/$sim_base/$batchname" || die "mkdir failed"
   echo Copying needed files to $runhost:./$sim_base/$batchname/
   scp -Cr $filelist $batchname $extra_source $runhost:./$sim_base/$batchname/ || \
     die "scp -Cr $filelist $batchname $runhost:./$sim_base/$batchname/ failed"
fi

if [ "$run" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && run_on_host --show "cd $sim_dir;$job_submit $batchname"
  exit 0
fi

message="$(run_on_host "cd $sim_dir;$job_submit $batchname")" || die
qecho "$message"

if [ "$wait" = "yes" ]; then
  sleep 10
  job_id="$(print_jobids $batchname)"
  [[ -z "$job_id" ]] && die "Oh oh could not fetch job_id"
  qecho "Waiting for $batchname ($job_id) to finish"
  quiet="yes"
  while check_job $job_id; do
    sleep $sleeptime;
  done
  copy_back $batchname
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resub}" ]] && [[ ! -f "$resub" ]] && exit 1
  exit 0
fi
