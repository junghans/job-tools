#! /bin/bash
#
# C.Junghans & K. Koschke
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#version 0.1   ,03.12.10 -- initial version from qstart
#version 0.1.1 ,06.12.10 -- fixed a bug in --alljobs
#version 0.1.2 ,07.12.10 -- added --queue option
#version 0.1.3 ,12.12.10 -- fixed a bug in --showlog
#version 0.1.4 ,17.12.10 -- always run on 8 cpus
#version 0.2.0 ,20.12.10 -- added default version check
#version 0.2.1 ,12.01.11 -- single cpu is also allowed
#version 0.2.2 ,19.01.11 -- fixed a bug when args were quoted
#version 0.2.3 ,20.01.11 -- bug in version 0.2.2 due to wrong logic
#version 0.2.4 ,28.01.11 -- nomail is now default
#version 0.2.5 ,04.02.11 -- updated help message
#version 0.2.6 ,04.02.11 -- added longhelp message
#version 0.2.7 ,17.02.11 -- fixed a bug when sourcing rcfile
#version 0.3.0 ,17.02.11 -- added --compenv
#version 0.3.1 ,25.02.11 -- queue is now automatic
#version 0.3.2 ,11.03.11 -- fixed a tcsh bug in --show-compenv

##############################################################
# NEVER EVEN change settings below, but in your ~/.q2startrc #
# because --selfupdate will overwrite it !                   #
##############################################################

#BEGIN DEFAULTS
#defaults options, uncomment and change only the lines you really need to change
#keep it in bash style, source must work on this file

############## QUEUE stuff #########
#path to queue utils need later on
queue_path="/opt/SGE/bin/lx26-amd64"

#command to submit a job
job_submit="$queue_path/qsub"
#command to get status
job_status="$queue_path/qstat"
#command to cancel/delete a job
job_kill="$queue_path/qdel"
#command to cancel/delete a job
job_info="$queue_path/qconf"
#extra options for submit
submit_opts=""
#name of the host, where to submit the jobs
#maybe create an sshalias
submit_host="$HOSTNAME"
#the real hostname ($HOSTNAME), when logon submit_host
real_submit_hostname="$submit_host"
#submit the script by default: yes/no
submit="yes"
#default number of cpus to use
ncpus=1
#default wall clock time
wall_time="36:00:00"
#on which node to run by default, empty = no default
hostname=""
#overwrite the queue to be used this, empty = normal queue
specialq=""

########### MPI stuff ###############
#should mpirun (or equivalent) be added: yes/no
mpi_job="yes"
#the command to add for mpi jobs, empty means from set_compenv
mpirun_cmd=""
#compiler environment to be used by default
compenv="gnu"

############# Script option ########
#default trunc name of the submit script
name="q2"
#template to add to the script name
template="_XXXXX"
#automatically naming of the script: yes/no
auto="no"
#add timing commands: yes/no
time="no"
#use scratch space by default: yes/no
scratch="no"
#base dir to scratch space
scratch_dir="/usr/scratch"
#file to create if jobs is finished
finish_file=""
#rebsumit the job until this file exists
resubmit_file=""
#file to source before running the command
extra_source=""
#default option if none are given on the command line
default_opts=""
#extra code to put in script after changing to the PWD and copy of files
# but before running the job
extra_begin_code=""
#extra code to put in script after running the job, but before copy back
extra_end_code=""

########### other options #####
#be quiet or not: yes/no
quiet="no"
#run in script mode: yes/no
scriptmode="no"
#wait for the jobs to finish: yes/no
wait="no"
#sec to wain in the --wait loop
sleeptime=900
#default email adress
#empty/none = no email, auto = leave it to queue where to send the mail
mail="none"
#header to show with --showjobs option
header="JOBS ON THINC (thincXXX)"
#shell to be used by default, none=bash
myshell="${SHELL##*/}"
if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ] || [ "$myshell" = "zsh" ]; then
  set=""
  export="export "
elif [ "$myshell" = "tcsh" ]; then
  set="set "
  export="setenv "
else
  die "Unsupported shell"
fi
#END DEFAULTS

#internal options not set in rcfile
#usage print out
usage="${0##*/} [OPTIONS] COMMAND [options]"
#internal for set command, empty for bash, but 'set' for tcsh
set=""
#was the connection already checked
checked_connection="no"
#if the job submit directly
direct_submit="no"
#user given script name
batchname=""
#user given log file name
logfile=""
#rc to read
rcfile="~/.${0##*/}rc"
#where to look for updates
branch=mpip
selfurl="http://job-tools.cj-overlay.googlecode.com/hg/q2start?r=$branch"
verurl="http://www.mpip-mainz.mpg.de/~junghans/job-tools/version.php"
#compiler environment possible
compenvs=" gnu intel  pgi "

#workaround until SGE is working everywhere
export SGE_CELL="THINCC1"
export SGE_CLUSTER_NAME="p6444"
export SGE_ROOT="/opt/SGE"

qecho() {
  [[ "$quiet" = "no" ]] && echo -e "$*"
}

die() {
  [ -z "$1" ] || echo -e "$*" >&2
  [ "$direct_submit" = "no" ] && [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$real_submit_hostname" ]; then
    ssh="bash -c"
  else
    if [ "$checked_connection" = "no" ]; then
      ssh $submit_host true || die "Heuristic connection check failed.
Change 'submit_host' variable in your setting file ($rcfile), which is now set to '$submit_host'.

To generate a setting file run:
   '${0##*/} --showdefaults > $rcfile'"
      checked_connection="yes"
    fi
    ssh="ssh $submit_host"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  [ -z "$message" ] || echo -e "$message"
}

check_job() {
  local message
  number_check "$1" "--checkjob"
  message=$(run_on_host "$job_status -u $USER") || die
  if [ -z "$(echo -e "$message" | awk "(\$1==$1){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host NOT found"
    return 1
  elif [ -z "$(echo -e "$message" | awk "(\$1==$1)&&(\$5 !~ /E/){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host in error state"
    return 1
  else
    qecho "Job '$1' on $submit_host found"
    return 0
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  number_check "$1" "--killjob"
  run_on_host "$job_kill $1"
  return $?
}

stat_job() {
  number_check "$1" "--statjob"
  run_on_host "$job_status -j $1"
  return $?
}

submit_job() {
  local message path
  [ -z "$1" ] && die "submit_job: missing argument"
  [ -f "$1" ] || die "Could not find $1"
  path="$(get_path_from_script $1)" || die
  message="$(run_on_host "cd $path;$job_submit $submit_opts $1")" || die
  qecho "$message"
}

print_jobids() {
  local message job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  message=$(run_on_host "$job_status -u $USER") || die
  for job_id in $(echo -e "$message" | awk "(\$3 ~ /${1:0:8}/){print \$1}"); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

extra_queue_header() {
  [ -z "$1" ] && die "extra_queue_header: Missing argument"
  number_check "$1" "extra_queue_header"
  [ $1 -gt 1 ] && echo "#$ -pe openmpi $1"
}

cpunr_to_queuename() {
  local secs
  [ -z "$1" ] && die "cpunr_to_queuename: Missing argument"
  number_check "$1" "cpunr_to_queuename"
  secs=$(walltime_to_sec $wall_time) || die
  [ $secs -gt 129600 ] && die "Wall time bigger than 36h is not possible"
  if [ -n "$specialq" ]; then
    echo "$specialq"
  elif [ $1 -eq 1 ]; then
    echo ""
  elif [ $1 -eq 8 ]; then
    echo ""
  else
    die "Do not know how to handle this Number of cpus '$1' - only 1/8 cpus are supported at this time"
  fi
}

set_compenv(){
  [ -z "$1" ] && die "set_compenv: missing option"
  #do not overwrite user settings
  [ -n "$mpirun_cmd" ] && return 0
  case $1 in
    gnu)
      mpirun_cmd="/sw/linux/mpi/gcc/openmpi/bin/mpirun"
    ;;
    intel)
      mpirun_cmd="/sw/linux/mpi/intel/openmpi/bin/mpirun"
    ;;
    pgi)
      mpirun_cmd="/sw/linux/mpi/pgi/openmpi/bin/mpirun"
    ;;
    *)
      die "this should never appear - something went wrong in set_compenv"
    ;;
  esac
}

show_compenv(){
  [ -z "$1" ] && die "show_compenv: missing option"
  case $1 in
    gnu)
      echo "${set}LD_LIBRARY_PATH=/sw/linux/mpi/gcc/openmpi/lib:\$LD_LIBRARY_PATH;"
      echo "${set}PATH=/sw/linux/mpi/gcc/openmpi/bin:\$PATH;"
      echo "${set}CC=gcc;"
      echo "${set}F77=gfortran;"
      echo "${set}CXX=g++;"
      echo "${export}LD_LIBRARY_PATH;"
      echo "${export}PATH;"
      echo "${export}CC;"
      echo "${export}F77;"
      echo "${export}CXX;"
    ;;
    intel)
      #order is important: source intel vars first before overriding openmpi bin by
      #exporting the intel/openmpi path
      #2011.1.107 is the newest intel compiler for our cluster; it did produce binary code that crashes 
      #           with a seg fault when the '-ipo' flag was used
      echo 'source /sw/linux/intel/composerxe-2011.0.084/composerxe-2011.1.107/bin/iccvars.sh intel64;'
      #use the 11.1 version if you need the '-ipo' flag
      #echo 'source /sw/linux/intel/Compiler/11.1/072/bin/iccvars.sh intel64;'
      echo "${set}PATH=/sw/linux/mpi/intel/openmpi/bin/:\$PATH;"
      echo "${set}LD_LIBRARY_PATH=/sw/linux/mpi/intel/openmpi/lib/:\$LD_LIBRARY_PATH;"
      echo "${set}CC=icc;"
      echo "${set}F77=ifort;"
      echo "${set}CXX=icpc;"
      echo "${export}PATH;"
      echo "${export}LD_LIBRARY_PATH;"
      echo "${export}CC;"
      echo "${export}F77;"
      echo "${export}CXX;"
    ;;
    pgi)
      echo "${set}CC=pgcc;"
      echo "${set}F77=pgfortran;"
      echo "${set}CXX=pgCC;"
      echo "${set}PATH=/sw/linux/mpi/pgi/openmpi/bin/:/sw/linux/pgi-10.9/linux86-64/10.9/bin/:\$PATH;"
      echo "${set}LD_LIBRARY_PATH=/sw/linux/pgi-10.9/linux86-64/10.9/lib/:/sw/linux/pgi-10.9/linux86-64/10.9/libso/:/sw/linux/mpi/pgi/openmpi/lib/:\$LD_LIBRARY_PATH;"
      echo "${export}CC;"
      echo "${export}F77;"
      echo "${export}CXX;"
      echo "${export}PATH;"
      echo "${export}LD_LIBRARY_PATH;"
    ;;
    *)
      die "this should never appear - something went wrong in show_compenv"
    ;;
  esac
}

walltime_to_sec() {
  local secs wall
  [ -z "$1" ] && die "walltime_to_sec: Missing argument"
  [ -z "${1/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
  wall="$1"
  secs=${wall##*:}
  wall=${wall%:??}
  secs=$(( $secs + 60*${wall##*:} ))
  wall=${wall%:??}
  secs=$(( $secs + 3600*${wall##*:} ))
  echo "$secs"
}

queue_info() {
  local queue
  if [ -n "$specialq" ]; then
    run_on_host "$job_info -sq $specialq"
  elif [ -n "$1" ]; then
    number_check "$1" "--queueinfo"
    queue="$(cpunr_to_queuename "$1")" || die
    if [ -z "$queue" ]; then
      die "queue_info: the queue is defined automatically, if you want to see more info about a queue specify it with --queue before '--queueinfo'"
    else
      run_on_host "$job_info -sq $queue"
    fi
  else
    run_on_host "$job_info -sql"
  fi
  return $?
}

get_version() {
  sed -ne 's/^#version[[:space:]]*\([^[:space:]]*\)[[:space:]]*,.*$/\1/p' $1 | sed -n '$p'
}

get_webversion() {
  local version
  if [ "$1" = "-q" ]; then
    version="$(wget -qO- "${selfurl}" | get_version)"
  else
    [ -z "$(type -p wget)" ] && die "wget not found"
    version="$(wget -qO- "${selfurl}" )" || die "self_update: wget fetch from $selfurl failed"
    version="$(echo -e "${version}" | get_version)"
    [ -z "${version}" ] && die "get_webversion: Could not fetch new version number"
  fi
  echo "${version}"
}

version_check() {
  [ -z "$(type -p wget)" ] && return 1
  [ "$(wget -q -O - "$verurl?name=${0##*/}&i=${USER}%40$HOSTNAME" 2>&1)" = "active" ] || return 1
  old_version="$(get_version $0)"
  [ "$1" = "-q" ] && new_version="$(get_webversion -q)" || new_version="$(get_webversion)"
  [ "$1" = "-q" ] || echo "Version of $selfurl is: $new_version"
  [ "$1" = "-q" ] || echo "Local Version: $old_version"
  expr "${old_version}" \< "${new_version}" > /dev/null
  return $?
}

self_update() {
  [ -z "$(type -p wget)" ] && die "wget not found"
  if version_check; then
    echo "I will try replace myself now with $selfurl (CTRL-C to stop)"
    sleep 5
    wget -O "${0}" "${selfurl}"
  else
    echo "No updated needed"
  fi
}

showhelp() {
 cat << eoh
    A script to start $header.
    It builds a very simple submit script (see -p options) and
    run it.

    $usage

    (later options overwrite previous ones, short options can be concatenated)

    SCRIPT OPTIONS:
    -n, --name NAME      Change trunc name of script
                         Default: $name
ADV     --batch NAME     Change name of the submit script
ADV                      Default:  \$(mktemp ${name}$template)
ADV                      (Argument is NAME+TEMPLATE)
ADV -l, --log NAME       Change name of the output file
ADV                      Default: log_"batch"
ADV     --template TEXT  Change template for mktemp
ADV                      Default: $template
ADV -a, --auto           Use first argument as name
ADV     --script         Will use the argument as base scripts and concatenate them
ADV                      (implies --nompi)
ADV -e, --emptytemplate  Same as --template ""
ADV -m, --mail NAME      send mail to NAME
ADV                      default: '$mail' (use 'auto' for automatic)
ADV -f, --finish NAME    Touches file NAME when succesfully finished
ADV -t, --time           Adds a date command before and after the command
    -p, --print          Only print the submit script (implies --nosubmit)
ADV     --nosubmit       Do submit the script, only create it (useful with --submit)
ADV     --submit   FILE  Submit the script FILE
ADV -r, --resubmit FILE  Resub the script if exit status was 0 and FILE not exist
ADV -w, --wait           Waits for the job to finish
ADV                      Exit status from existence of FILE from --finish or --resubmit
ADV     --sleeptime      Changes the sleeptime for --wait
ADV                      Default: $sleeptime
ADV     --shell NAME     Change the shell to use, script will sources ~/.XXXrc
ADV                      Default: $myshell
ADV     --source FILE    Source this file before run the progam
ADV     --scratch        Use scratch on "$scratch_dir/\$USER/"
ADV     --needed FILES   Give the files needed to be copy to the scratch dir to
ADV                      run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
ADV                      (implies --scratch)
ADV     --cpback FILE    Copy back files from scratch, which was start with BATCH and
ADV                      remove them afterwards (useful after crash)

    QUEUE OPTIONS:
    -N                   Number of cpus (also determines the queue together with walltime)
                         Possible: 1,8
                         Default: $ncpus
ADV     --nompi          This is NOT a mpi job, so do NOT add mpirun (or equivalent)
ADV                      to the command line (for ncpus > 1) automatically
        --walltime TIME  Change wall clock time (use 1cpu and  00:20:00 for test queue)
                         Default: $wall_time
ADV     --runat HOST     Specify the host to run yourself
ADV     --runatnow HOST  like --runat, but one do it one time, not after the resubmitting
ADV     --queue  NAME.q  Overwrite the queue to be used with NAME.q
ADV                      (also in the case of --queueinfo)
ADV     --compenv NAME   Set your environment variables according to the compiler NAME
ADV                      Options: $compenvs 
ADV                      Default: $compenv
ADV     --show-compenv   Show compiler environment variables (set with --compenv NAME first)
ADV                      Useful in build scripts 'eval \$(${0##*/} --compenv icc --show-compenv)'


    JOBS OPTIONS:
        --showjobs        Show my jobs running (on $submit_host)
        --alljobs         Show all jobs running (on $submit_host)
ADV     --checkjob JOB_ID Return true if job is still running (useful with -f)
ADV                       "while ${0##*/} -q --checkjob JOB_ID; do :; done"
ADV     --pcheck PATTERN  Return true if at least one job matching a pattern is still running
ADV                       PATTERN is search in the name column (useful with -f)
ADV                       "while ${0##*/} -q --pcheck NAME; do :; done"
        --showlog  JOB_ID Show logfile for running job with number JOB_ID
ADV     --showdir  JOB_ID Show pwd of simulation
ADV     --taillog  JOB_ID Same as --showlog but tail and follow
        --killjob  JOB_ID Kill job with number JOB_ID
ADV     --statjob  JOB_ID Show status of the job with number JOB_ID
ADV     --pkill PATTERN   Kill all jobs matching a pattern
ADV     --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
        --queueinfo [NR]  Show info about some queue [1|2|8] or all queues
ADV     --header          Show info header

    COMMON OPTIONS:
ADV     --               End of options (if program starts with -)
ADV -q, --quiet          Be quiet
        --rcfile FILE    Extra setting file with defaults to read
                         Default: read only $rcfile if exist
ADV     --showdefaults   Show the default settings before reading $rcfile and the
ADV                      file given by --rcfile, useful to create own rcfile with:
ADV                      "${0##*/} --showdefaults > $rcfile"
ADV -v, --version        Prints version
        --selfupdate     Do a self update from googlecode
    -h, --help           Show short help message
        --longhelp       Show long help message

ADV Notes for usage of scratch space:
ADV ------------------------
ADV -The usage of the scratch space is complicated, use it with care!
ADV -Only use scratch space if you expect heavy input/output load
ADV -You may add the input files to copy to the scratch dir  with --needed
ADV  or use "--needed '*'", if want to copy all files of the current dir.
ADV -If the binary in not in your PATH, give the full path of binary or
ADV  add itself to --needed itself and use "./"
ADV -Remember, copying input files to the scratch dir and output file back here
ADV  takes time, so substract time needed for that from the wall of the actual simulation!

    Examples:
       ${0##*/} -8p sleep 30
       ${0##*/} -8p --nompi mpirun -np 8 sleep 30
       ${0##*/} --name gromacs mdrun -v
       ${0##*/} -8 --needed topol.tpr mdrun
       ${0##*/} echo -e 'SOL\\\\nSOL' \| g_rdf -b 100 -n index.ndx
       ${0##*/} -8 --resubmit confout.gro --nompi mdrun -cpi state.cpt -maxh 36
       ${0##*/} -8 --source ~/myGromacs/GMXRC --resubmit confout.gro mdrun -append -cpi state.cpt -maxh 36
                (Note: -cpi is smart, the first time mdrun will start normal!)
       ${0##*/} -8 --needed '*' --resubmit confout.gro  mdrun -append -cpi state.cpt -maxh 35
                (Note: --needed '*' needs a separate dir for the simulation!)
ADV    ${0##*/} -8 --compenv intel mdrun
ADV    ${0##*/} --compenv pgi --show-compenv

    Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_logs() {
  local message path logfile
  [ -z "$2" ] && die "show_logs: Missing argument"
  number_check "$1" "--showlog/--taillog"
  message=$(run_on_host "$job_status -r -j $1") || die
  path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
  logfile=$(echo -e "$message" | awk '/^stdout_path_list:/{ print $2}')
  #strange standard stdout_path_list: begins with NONE:NONE:
  logfile=${logfile#NONE:}
  logfile=${logfile#NONE:}
  $2 $path/$logfile
  return $?
}

show_path() {
  local message path
  [ -z "$1" ] && die "show_path: Missing argument"
  number_check "$1" "--showdir"
  message=$(run_on_host "$job_status -r -j $1") || die
  path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
  [ -z "$path" ] && die "show_path: Could not get path"
  echo "$path"
  return $?
}

copy_back() {
  local path logfile host
  [ -z "$1" ] && die "copy_back: Missing argument"
  [ -f "$1" ] || die "copy_back: Could not found $1"
  [ -z "$(grep -e "${0##*/}" $1)" ] && die "$1 seems NOT to be a '${0##*/}' script"
  logfile=$(sed -n 's/^#$ -o //p' $1) || die "copy_back: could not get logfile"
  [ -f "${logfile}" ] || die "copy_back: logfile '$logfile' not found"
  host="$(sed -n 's/^Hi, I am job [0-9] on \(.*\) in .*$/\2/p')"
  [ -z "$host" ] && die "copy_back: Could not get hostname for logfile '$logfile'"
  path="$(sed -n 's/^Copy needed files to \(.*\)$/\1/p')"
  [ -z "$path" ] && die "copy_back: Could not get path for logfile '$logfile'"
  echo Copying back data from $host:$path/ to .
  scp -Cpr "$host:$path/*" . || die "scp -Cr $host:./$path/* . failed"
  ssh $host "rm -rf $path" || die "ssh $host rm -rf $path failed"
  return $?
}

get_path_from_script(){
  local path
  [ -z "$1" ] && die "get_path_from_script: Missing argument"
  [ -f "$1" ] || die "get_path_from_script: Could not found"
  [ -z "$(grep -e "${0##*/}" $1)" ] && die "$1 seems NOT to be a '${0##*/}' script"
  path="$(awk '/^cd/{print $2;exit 0}' $1)"
  [ -z "$path" ] && die "get_path_from_script: found not grep path from $1"
  echo "$path"
}

################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done

if [ -f ${rcfile/\~/$HOME} ]; then
  source ${rcfile/\~/$HOME} || die "Error when sourcing $rcfile, correct it or remove it"
  qecho "I have sourced $rcfile"
fi

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  --rcfile )
   rcfile="$2"
   source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
   qecho "I have source $rcfile"
   shift 2;;
  --showdefaults )
   sed -ne '/^#BEGIN DEFAULTS/,/^#END DEFAULTS/p' $0 | sed -e '1d' -e '$d' -e '/^[^#]/s/^/#/'
   exit 0;;
  -[0-9] )
   ncpus=${1#-}
   number_check "$ncpus" "$1"
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   submit="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpi_job="no"
   shift ;;
   --nosubmit | --norun)
   submit="no"
   shift ;;
   --submit)
   direct_submit="yes"
   submit_job "$2"
   exit $? ;;
   --template )
   template="$2"
   shift 2;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --scratch )
   scratch="yes"
   shift ;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -r | --resub | --resubmit)
   resubmit_file="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2
   #define 'set' and 'export' commands first
   if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ] || [ "$myshell" = "zsh" ]; then
     set=""
     export="export "
   elif [ "$myshell" = "tcsh" ]; then
     set="set "
     export="setenv "
   else
     die "Unsupported shell"
   fi ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun | --nompi)
   mpi_job="no"
   shift ;;
   --walltime )
   wall_time="$2"
   [ -z "${wall_time/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
   shift 2;;
   --runat )
   hostname="$2"
   shift 2;;
   --runatnow )
   submit_opts="$submit_opts -l hostame=$2"
   shift 2;;
  --queue )
   specialq="$2"
   shift 2;;
   --compenv )
   compenv="$2"
   [ -z "${compenvs/* $compenv *}" ] || die "The chosen compiler environment $compenv is not understood"
   shift 2;;
   --show-compenv )
   show_compenv $compenv
   exit $?
   ;;
   --showjobs )
   run_on_host "$job_status -u $USER"
   exit $?;;
   --alljobs )
   run_on_host "$job_status -u \\*"
   exit $?;;
   --cpback )
   copy_back $2
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --statjob )
   stat_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   queue_info $2
   exit $?;;
   --showdir )
   show_path "$2"
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tailf"
   exit $?;;
  -v | --version)
   echo "${0##*/}, version $(get_version $0) ($branch branch) by C. Junghans & K. Koschke"
   exit 0;;
  --selfupdate)
   self_update
   exit $?;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp | sed -e '/^ADV /d' -e 's/^    //'
   exit 0;;
  --longhelp)
   showhelp | sed -e 's/^ADV/   /' -e 's/^    //'
   exit 0;;
  --)
   shift
   break;;
  *)
   die "Unknown option '$1'";;
 esac
done

if version_check -q; then
  x=${0##*/}; x=${x//?/#}
  echo "##################################$x"
  echo "# Your version of ${0##*/} is obsolete ! #"
  echo "# Please run '${0##*/} --selfupdate'     #"
  echo "##################################$x"
  unset x
fi

if [ -z "$1" ]; then
  [ -z "${default_opts}" ] && die "Missing program name (try --help)"
  set -- ${default_opts}
fi

[[ $auto = "yes" ]] && name=${1##*/}

if [ -z "$batchname" ]; then
  #template contains no 'X'
  if [ -z "${template//[^X]}" ]; then
    batchname="${name}"
  elif [ -n "$(type -p mktemp)" ]; then
    batchname=$(mktemp -u ${name}${template}) || die "mktemp could not generate file"
  else
    echo No mktemp found >&2
    l=${template//[^X]}
    l=${#l}
    t2=${template}
    batchname=${0}
    while [ -f ${batchname} ]; do
      for ((i=0;i<$l;i++)); do
        t2=${t2/X/${RANDOM:0:1}}
      done
      batchname=${name}${t2}
    done
  fi
  touch ${batchname}
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "submit script: $batchname"
  qecho "logfile: $logfile"
fi

if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ]; then
  echo "#! /bin/bash" > $batchname
elif [ "$myshell" = "zsh" ]; then
  echo "#! /usr/bin/zsh" > $batchname
elif [ "$myshell" = "tcsh" ]; then
  echo "#! /bin/tcsh" > $batchname
else
  die "Unsupported shell"
fi

set_compenv $compenv || die

cat <<EOF >> $batchname
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using ${0##*/}, version $(get_version $0)

#sge options
#$ -cwd
#$ -j y
#$ -o $logfile
#$ -l h_rt=${wall_time}
EOF
queue_name="$(cpunr_to_queuename $ncpus)" || die
[ -n "$queue_name" ] && echo "#$ -q ${queue_name}" >> $batchname

[ -n "$(extra_queue_header $ncpus)" ] && extra_queue_header $ncpus >> $batchname
[ -n "$hostname" ] && echo "#$ -l hostname=${hostname}" >> $batchname

#To mail or not to mail
if [ -z "$mail" ] || [ "$mail" = "none" ]; then
  echo "#$ -m n" >> $batchname
else
  echo "#$ -m e" >> $batchname
  [ "$mail" = "auto" ] || echo "#$ -M $mail" >> $batchname
fi

if [ "$myshell" = "bash" ]; then
  echo "#$ -S /bin/bash" >> $batchname
  [ -f ~/.bashrc ] && sh_source="source ~/.bashrc"
elif [ "$myshell" = "zsh" ]; then
  echo "#$ -S /usr/bin/zsh" >> $batchname
  [ -f ~/.zshrc ] && sh_source="source ~/.zshrc"
elif [ "$myshell" = "tcsh" ]; then
  echo "#$ -S /bin/tcsh" >> $batchname
  if [ -f ~/.tcshrc ]; then
    sh_source="source ~/.tcshrc"
  elif [ -f ~/.cshrc ]; then
    sh_source="source ~/.cshrc"
  fi
elif [ "$myshell" = "none" ]; then
  echo "#$ -S /bin/bash" >> $batchname
fi

cat <<EOF >>$batchname

${sh_source}

#COMPILER and MPI VARIABLES
$(show_compenv $compenv)

cd $PWD
echo Hi, I am job \$JOB_ID on \$HOSTNAME in \$PWD

EOF
[ -n "$extra_source" ] && echo "source $extra_source" >> $batchname
if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname
#Copy the needed files
${set}olddir=\$PWD
${set}newdir=$scratch_dir/\$USER/\$JOB_ID
mkdir -p \$newdir || exit 1
EOF
[ -n "$filelist" ] && cat <<EOF >>$batchname
echo Copy needed files to \$newdir
echo $filelist
cp -r $filelist \$newdir
echo finished copying files
EOF
echo 'cd $newdir' >> $batchname
fi

if [ -n "${extra_begin_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra begin code
${extra_begin_code}
#END of extra begin code

#Extra compiler option
EOF
fi

echo echo Starting simulation in \$PWD >> $batchname

[[ "$time" = "yes" ]] && echo date >> $batchname
if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname
  done
  cmdline=""
else
  #do not add quotes to the first argument
  cmdline="$1"
  shift
  for i in "$@"; do
    [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
  done
  if [ "$mpi_job" = "yes" ] && [ $ncpus -gt 1 ]; then
    cmdline="$mpirun_cmd -np $ncpus $cmdline"
  fi
fi

cat <<EOF >>$batchname
$cmdline
${set}result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

if [ -n "${extra_end_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra end code
${extra_end_code}
#END of extra end code
EOF
fi

if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname

#Copy files back
echo Copy back files:
echo *
cp -ru * \$olddir
echo finished copying files
cd \$olddir
echo Removing scratch dir
[ \$result -eq 0 ] && rm -fr \$newdir
EOF
fi

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ -n "$resubmit_file" ]; then
  [ -f "$resubmit_file" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $job_submit in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f '$resubmit_file' ] && $job_submit $PWD/$batchname" >> $batchname
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && [ -f $resubmit_file ] && touch $finish_file" >> $batchname
else
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && touch '$finish_file'" >> $batchname
fi

if [ "$submit" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && qecho "to submit the script run: '${0##*/} --submit $batchname'"
  exit 0
fi

submit_job $batchname

if [ "$wait" = "yes" ]; then
  qecho "Waiting for $batchname to finish"
  quiet="yes"
  while pcheck_job $batchname; do
    sleep $sleeptime;
  done
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resubmit_file}" ]] && [[ ! -f "$resubmit_file" ]] && exit 1
  exit 0
fi
