#!/bin/bash
#
# (C) 2008 Chr. Junghans
# junghans@mpip-mainz.mpg.de

#version 2.3   -- fix problem with "./" in progname
#version 2.4   -- issue with 2>>&1
#version 2.4.4 -- fixed a problem with file names with "-"
#version 2.4.5 -- change the parameter matching
#version 2.5.0 -- added nice option
#version 2.5.1 -- fixed a bug in --add
#version 2.6.0 -- allowing better short opts
#version 2.6.1 -- fixed string bug in short opts
#version 2.7.0 -- fixed the problem with too gib attachments
#version 2.7.1 -- remove base name function
#version 3.0.0 -- make more use of functions and clean up
#version 3.1.0 -- added --checkjobs --showjobs
#version 3.1.1 -- bug in start batch
#version 3.1.2 -- make use of sed
#version 3.1.3 -- added --rmjobs --showlog
#version 3.1.4 -- added --taillog
#version 3.1.5 16.04.08 -- better version system
#version 3.2.0 08.07.08 -- allows to use lammpi
#version 3.3.0 23.09.08 -- autogenerate of startbatch name
#version 3.4.0 26.09.08 -- added killjob option
#version 3.4.1 27.09.08 -- bug with number
#version 3.4.1 06.10.08 -- added --progname, --checkjob and --finish
#version 3.5.0 06.10.08 -- added unique job_id
#version 3.5.1 06.10.08 -- faster --checkjob
#version 3.6.0 07.10.08 -- consitency with qstart
#version 3.6.1 07.10.08 -- better --showjobs
#version 3.6.2 08.10.08 -- notemplate is not emptytemplate
#version 3.6.3 08.10.08 -- bug in --name
#version 3.6.4 08.10.08 -- bug in short opts
#version 3.6.5 08.10.08 -- bug in show_jobs with empty lines
#version 3.6.6 08.10.08 -- added --header
#version 3.6.7 08.10.08 -- added --show_job
#version 3.6.8 08.10.08 -- bug in --checkjob for remote
#version 3.6.9 13.10.08 -- bug in --checkjobs
#version 3.7.0 15.10.08 -- bug in kill_job
#version 3.7.1 01.12.08 -- bug in kill_job
#version 3.7.2 23.09.09 -- added header to batch file, which to type
#version 3.7.3 30.11.09 -- fixed a bug in check_exist + source bashrc
#version 3.8.0 22.01.10 -- major clean up
#version 3.8.1 22.01.10 -- rm batchname, when crashing


##########################################
################# Defaults ###############
##########################################

usage="Usage: ${0##*/} [OPTIONS] PROGRAM [PROGRAM-OPTIONS]"
#mail=$USER
mail="$USER@mpip-mainz.mpg.de"
ncpus="1"
hostlist=""
batchname=""
name="l"
hostlist="liste.mpi"
mpilist="mpilist"
findbest='no'
runhost="$HOSTNAME"
run='yes'
lines='100'
add='>'
quiet='no'
jobfile="$HOME/.runingjobs"
nice="19"
mpitype="LAM"
finish_file=""
uni_num_file="$HOME/.start_unimum"
template="_XXXXX"
auto="no"
time="no"
header="LOCAL JOBS"
myshell="${SHELL##*/}"

##########################################
################# Functions ##############
##########################################

qecho() {
  [[ "$quiet" = "no" ]] && echo "$*"
}

die() {
  echo -e "$*" >&2
  [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ "$1" = "--show" ] && { shift;ssh="echo "; }
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$runhost" ]; then
    ssh="${ssh}bash -c"
  else
    ssh="${ssh}ssh $runhost"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  [ -z "$message" ] || echo -e "$message"
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

check_jobs(){
  local i
  check_jobfile
  for i in $(awk '{print $1}' $jobfile); do
    check_job $i
  done
  return $?
}

check_job(){
  local runhost pid message
  runhost=$(show_column $1 2) || die
  pid=$(show_column $1 3) || die
  message=$(run_on_host "ps -p $pid || true") || die
  if [ -z "${message/*$pid*}" ]; then
     qecho Job $1: pid $pid on $runhost found
     return 0
  else
    qecho Job $1: pid $pid on $runhost NOT found
    return 1
  fi
}

check_jobfile() {
  [ -r "$jobfile" ] || die "Jobfile '$jobfile' not readable or not found!"
  return 0
}

job_exist() {
  [ -z "$1" ] && die "job_exist: Missing argument"
  check_jobfile
  [ -z "$(awk -v id="$1" '($1==id){print $0}' $jobfile)" ] && die "Job $1 not found !"
  return 0
}

kill_job() {
  local runhost pid gpid pids
  [ -z "$1" ] && die "kill_job: Missing argument"
  runhost=$(show_column $1 2) || die
  pid=$(show_column $1 3) || die
  $(run_on_host "ps --ppid $pid -o pid= | xargs kill") || \
    die "Could kill childs of pid $pid\nYou may want to run '${0##*/} --rmjob $1' to remove it from the joblist"
  return 0
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

print_jobids() {
  local job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  for job_id in $(awk "(\$4 ~ /${1:0:8}/){print \$1}" $jobfile); do
    echo $job_id
  done
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

rm_job() {
  sed -i "/^$1 /d" $jobfile || die "rm_job: sed failed"
  qecho Job $1 removed from jobfile
}

showhelp() {
 cat << eoh
Make startbatch for PROGRAM and run it !
It send you and email and add in to '$jobfile'
$usage

    (later options overwrite previous ones, short options can be concatenated)

to do: print

START OPTIONS:
-n, --name NAME       Change global name of script
                      Default: $name
    --batch NAME      Change name of batch file
                      Default: \$(mktemp ${name}$template)
                      (Argument is NAME+TEMPLATE)
-l, --log FILE        Changes the name of the logfile,
                      default: log_"batchname"
    --template TEXT   Change template for mktemp
                      Default: $template
-a, --auto            Use first argument as global name
-e, --emptytemplate   Same as --template ""
-m, --mail NAME       send mail to NAME
                      default: '$mail'
-x, --nomail          will not use mail function
-f, --finish NAME     Create a file NAME when succesfully finished
                      Usefull with --checkjob and "[[ -f NAME ]] || exit 1"
-t, --time            Adds a date command before and after the command
-p, --print           Only print the batchscript (implies --norun)
    --norun           build batchfile, but do not run it

    --add             add output to the logfile
                      default: create new logfile (overwrite)
-c, --priority NUMBER Change nice factor
                      default: '$nice'
    --lines           change number of last lines of the logfile in the mail
                      default: '$lines'
    --shell NAME      Change the shell to use, script will sources ~/.XXXrc
                      Default: $myshell
-w, --wait            Waits for the job to finish
                      Exit status from existence of FILE from --finish

MPI OPTIONS:
-N                     start mpi job with N CPUS
                       Default: $ncpus
                       (ignores -r, -b, uses '$mpilist')
    --hostlist FILE    name of the hostfile to use with mpi CH4
                       Default: $hostlist
                       if file does not exist it is generated by $mpilist
                       (ignored when runing on 1 cpu)
    --mpitype[CH4|LAM] change the standard mpi implentation
                       default: '$mpitype'

REMOTE OPTIONS:
-r, --runat HOST      run on HOST instead of localhost
-b, --best            run Program on the maschine with the
                      lowest load (uses '$mpilist')

JOBS OPTIONS:
    --showjobs        Show running job (start by ${0##*/})
    --checkjob JOB_ID Return true if job is still running (useful with --f)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --pcheck PATTERN  Return true if at least one job matching a pattern is still running
                      PATTERN is search in the simname (useful with --f)
                      "while ${0##*/} -q --checkjob NAME; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --showdir  JOB_ID Show pwd of simulation
    --taillog  JOB_ID same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with JOB_ID
    --pkill PATTERN   Kill all jobs matching a pattern
    --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
    --checkjobs       Check if all jobs still exist
    --rmjob    JOB_ID Remove job with JOB_ID from jobfile
                      (useful after crash)
    --header          Show info header

COMMON OPTIONS:
-q, --quiet           be quiet
-v, --version         Prints version
-h, --help            Show this help message

Examples:
   ${0##*/} -8p sleep 30
   ${0##*/} -p sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_path() {
  local path
  path=$(show_column $1 4) || die
  [[ -d "$path" ]] || die "show_path: $path is not a dir"
  echo "$path"
  return $?
}

show_column() {
  local value
  [ -z "$2" ] && die "show_column: Missing argument"
  job_exist $1
  value="$(awk -v id="$1" -v co="$2" '($1==id){print $co}' $jobfile)"
  [[ -z "$value" ]] && die "show_column: Could not get value nr $2 for job $1"
  echo "$value"
  return $?
}

show_jobs() {
  check_jobfile
  [[ -n "$(sed '/^$/d' $jobfile)" ]] || exit 0
  echo JOB_ID HOSTNAME pid name jobtype PWD logfile batchfile
  sed '/^$/d' $jobfile
}

show_logfile() {
  local path logfile
  [ -z "$2" ] && die "show_logfile: Missing argument"
  path=$(show_path $1) | die
  logfile=$(show_column $1 7) || die
  #add path if logfile does not contain /
  [ -n "${logfile/*\/*}" ] && logfile="${path}/$logfile"
  [ -r "$logfile" ] || die "Logfile ($logfile) not readable or not found!"
  $2 $logfile
}

unique_number() {
  local number
  if [ -f "$uni_num_file" ]; then
    number=$(cat $uni_num_file)
  else
    number=1
  fi
  ((number++))
  echo $number > $uni_num_file
  echo $number
}

################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done
while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfgcr]}" != "${1}" ]; then
       set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
       set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  -p | --print )
   batchname="/dev/stdout"
   run="no"
   shift;;
  --log)
   logfile="$2"
   shift 2;;
  -n | --name)
   name="$2"
   shift 2;;
   --template )
   template="$2"
   shift 2;;
   -e | --emptytemplate )
   template=""
   shift ;;
   -a | --auto )
   auto="yes"
   shift ;;
  --add)
   add='>>'
   shift ;;
   -t | --time )
   time="yes"
   shift ;;
  -q | --quiet)
   quiet='yes'
   shift ;;
  -[0-9])
   ncpus="${1#-}"
   shift 1 ;;
  --hostlist)
   hostlist="$2"
   [ -r "$hostlist" ] || die "hostlist not readable !"
   shift 2 ;;
  --mpitype)
   mpitype="$2"
   shift 2;;
  -r | --runat)
   runhost="$2"
   findbest="no"
   shift 2 ;;
  -b | --best)
   findbest='yes'
   shift ;;
  -x | --nomail)
   mail=''
   shift ;;
  -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   if [ "$myshell" = "none"] || [ "$myshell" = "bash" ]; then
     :
   else
     die "We only support bash so far ;-)"
   fi
   shift 2;;
  --batchname)
   batchname="$2"
   shift 2 ;;
  -c | --priority)
   nice="$2";
   number_check "$nice" "--priority"
   if [ $nice -lt 0 ] || [ $nice -gt 19 ]; then
      die "argument after --nice should be a number between 0-19"
   fi
   shift 2 ;;
  --lines)
   lines="$2"
   number_check "$lines" "--lines"
   [ $lines -lt 1 ] && die "argument after --lines should be a number greater 0"
   shift 2 ;;
  --norun)
   run='no'
   shift ;;
  --checkjobs)
   check_jobs
   exit $?;;
  --checkjob)
   number="$2"
   number_check "$number" "--checkjob"
   check_job "$number"
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
  --showjobs)
   show_jobs
   exit $?;;
   --showdir )
   show_path $2
   exit $?;;
  --showlog)
   number="$2"
   number_check "$number" "--showlog"
   show_logfile "$number" "cat"
   exit $?;;
  --header)
   echo $header
   exit 0;;
  --taillog)
   number="$2"
   number_check "$number" "--taillog"
   show_logfile "$number" "tail -f"
   exit $?;;
  --rmjob)
   number="$2"
   number_check "$number" "--rmjob"
   rm_job "$number"
   exit $?;;
  --killjob)
   number="$2"
   number_check "$number" "--killjob"
   kill_job "$number"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   -w | --wait)
   wait="yes"
   shift 1;;
  -v | --version)
   echo ${0##*/}, $(sed -ne 's/^#\(version.*\) -- .*$/\1/p' $0 | sed -n '$p') by C. Junghans
   exit 0;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  *)
   die "Error: Unknown option '$1'";;
 esac
done

#Print usage and exit if no argument left
[ -z "$1" ] && die "Missing program name\n$usage\nhelp with --help"

[[ $auto = "yes" ]] && name=${1##*/}

#mpi things
if [ $ncpus -gt 1 ]; then
  [ -z "$(type mpirun)" ] && die "mpirun not found"
  if [ "$mpitype" == "CH4" ]; then
    #if mpijob is a file
    if [ -f "$hostlist" ]; then
      qecho "Generating $hostlist"
      [ -z "$(type $mpilist)" ] && die "$mpilist not found"
      qecho "This maybe takes a while..."
      $mpilist $quiet -o $hostlist $np || die "$mpilist failed"
    else
      qecho "Using $hostlist"
    fi
    mpicommand="mpirun -nolocal -np $ncpus -machinefile $hostlist "
  elif [ "$mpitype" == "LAM" ]; then
    [ -z "$(type lamboot)" ] && die "lamboot not found"
    mpicommand="mpirun -np $ncpus "
  else
    die "mpitype '$mpitype' unknown"
  fi
  jobtype='(MPI)'
else
  jobtype='(SP)'
fi

#find best host, if no host given and findbest is "yes"
if [ $ncpus -eq 1 ] && [ "$findbest" = "yes" ]; then
  [ -z "$(type $mpilist)" ] && die "$mpilist not found"
  qecho "This maybe takes a while..."
  runhost=$($mpilist -q -p 1) || die "$mpilist failed"
fi

if [ -z "$batchname" ]; then
  if [ -z "${template//[^X]}" ]; then
    batchname="${name}"
  elif [ -n $(type -p mktemp) ]; then
    batchname=$(mktemp -u $name${template}) || die "mktemp could not generate file"
  else
    echo No mktemp found >&2
    l=${template//[^X]}
    l=${#l}
    t2=${template}
    batchname=${0}
    while [ -f ${batchname} ]; do
      for ((i=0;i<$l;i++)); do
        t2=${t2/X/${RANDOM:0:1}}
      done
      batchname=${name}${t2}
    done
  fi
  touch ${batchname}
fi

if [ -z "$logfile" ]; then
   if [ "$batchname" = "/dev/stdout" ]; then
      logfile="log_$name"
   else
      logfile="log_$batchname"
   fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "qsubscript: $batchname"
  qecho "logfile: $logfile"
fi

job_id=$(unique_number)
cat > $batchname << eof
#! /bin/bash
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using $($0 --version)

exec $add $logfile 2>&1
echo -n "Renice job $job_id and childs: pid "
renice $nice -p \$\$
cd $PWD
eof

[[ "$myshell" = "bash" ]] && [ -f ~/.bashrc ] && echo "source ~/.bashrc" >> $batchname
[ $ncpus -gt 1 ] && [ "$mpitype" == "LAM" ] && echo "lamboot" >> $batchname
[[ "$time" = "yes" ]] && echo date >> $batchname

cat >> $batchname << eof
line="$job_id $runhost \$\$ $name $jobtype $PWD $logfile $batchname"
#add job to jobfile $jobfile
echo \$line >> $jobfile


${mpicommand}$*
result=\$?
[ \$result -ne 0 ] && echo "$name finished unhappy!"
eof

if [ -n "$mail" ]; then
   cat >> $batchname << eof
#mailstuff
if [ \$result -eq 0 ]; then
  tail -$lines $logfile | mail -s 'LSTART: $name finished ($logfile)' $mail
else
  tail -$lines $logfile | mail -s 'LSTART: $name aborted ($logfile)' $mail
fi
eof
fi

echo "#remove job from jobfile" >> $batchname
echo "sed -i '/^$job_id /d' $jobfile" >> $batchname
[[ "$time" = "yes" ]] && echo date >> $batchname
[[ -z "$finish_file" ]] || echo "[[ \$result -eq 0 ]] && touch $finish_file" >> $batchname

[ "$batchname" = "/dev/stdout" ] || chmod 700 $batchname
if [ "$run" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && run_on_host --show "nohup $PWD/$batchname >/dev/null 2>&1 &;'"
  exit 0
fi

run_on_host "nohup $PWD/$batchname >/dev/null 2>&1 &" || die
qecho "$batchname (id $job_id) started on $runhost"

if [ "$wait" = "yes" ]; then
  sleep 5
  qecho "Waiting for $batchname ($job_id) to finish"
  quiet="yes"
  while check_job $job_id; do
    sleep $sleeptime;
  done
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  exit 0
fi
