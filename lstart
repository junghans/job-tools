#! /bin/bash
#
# C.Junghans
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#version 2.3   -- fix problem with "./" in progname
#version 2.4   -- issue with 2>>&1
#version 2.4.4 -- fixed a problem with file names with "-"
#version 2.4.5 -- change the parameter matching
#version 2.5.0 -- added nice option
#version 2.5.1 -- fixed a bug in --add
#version 2.6.0 -- allowing better short opts
#version 2.6.1 -- fixed string bug in short opts
#version 2.7.0 -- fixed the problem with too gib attachments
#version 2.7.1 -- remove base name function
#version 3.0.0 -- make more use of functions and clean up
#version 3.1.0 -- added --checkjobs --showjobs
#version 3.1.1 -- bug in start batch
#version 3.1.2 -- make use of sed
#version 3.1.3 -- added --rmjobs --showlog
#version 3.1.4 -- added --taillog
#version 3.1.5 16.04.08 -- better version system
#version 3.2.0 08.07.08 -- allows to use lammpi
#version 3.3.0 23.09.08 -- autogenerate of startbatch name
#version 3.4.0 26.09.08 -- added killjob option
#version 3.4.1 27.09.08 -- bug with number
#version 3.4.1 06.10.08 -- added --progname, --checkjob and --finish
#version 3.5.0 06.10.08 -- added unique job_id
#version 3.5.1 06.10.08 -- faster --checkjob
#version 3.6.0 07.10.08 -- consitency with qstart
#version 3.6.1 07.10.08 -- better --showjobs
#version 3.6.2 08.10.08 -- notemplate is not emptytemplate
#version 3.6.3 08.10.08 -- bug in --name
#version 3.6.4 08.10.08 -- bug in short opts
#version 3.6.5 08.10.08 -- bug in show_jobs with empty lines
#version 3.6.6 08.10.08 -- added --header
#version 3.6.7 08.10.08 -- added --show_job
#version 3.6.8 08.10.08 -- bug in --checkjob for remote
#version 3.6.9 13.10.08 -- bug in --checkjobs
#version 3.7.0 15.10.08 -- bug in kill_job
#version 3.7.1 01.12.08 -- bug in kill_job
#version 3.7.2 23.09.09 -- added header to batch file, which to type
#version 3.7.3 30.11.09 -- fixed a bug in check_exist + source bashrc
#version 3.8.0 22.01.10 -- major clean up
#version 3.8.1 22.01.10 -- rm batchname, when crashing
#version 4.0.0 11.02.11 -- major cleanup and rewrite

#############################################################
# NEVER EVEN change settings below, but in your ~/.qstartrc #
# because --selfupdate will overwrite it !                  #
#############################################################

#BEGIN DEFAULTS
#defaults options, uncomment and change only the lines you really need to change
#keep it in bash style, source must work on this file

############## QUEUE stuff #########
#path to queue utils need later on
queue_path="/opt/SGE/bin/lx26-amd64"

#command to submit a job
job_submit="$queue_path/qsub"
#command to get status
job_status="$queue_path/qstat"
#commnd to cancel/delete a job
job_kill="$queue_path/qdel"
#commnd to cancel/delete a job
job_info="$queue_path/qconf"
#extra options for submit
submit_opts=""
#name of the host, where to submit the jobs
#maybe create an sshalias
submit_host="thop01"
#the real hostname ($HOSTNAME), when logon submit_host
real_submit_hostname="$submit_host"
#submit the script by default: yes/no
submit="yes"
#default number of cpus to use
ncpus=1
#default wall clock time
wall_time="36:00:00"
#on which node to run by default, empty = no default
hostname=""
#overwrite the queue to be used this, empty = normal queue
specialq=""
#no old node, will only use nodes >=thop63
no_old_nodes="no"

########### MPI stuff ###############
#should mpirun (or equivalent) be added: yes/no
mpi_job="yes"
#the command to add for mpi jobs
mpirun_cmd="/opt/lam/bin/mpirun"
#lamboot command
lamboot_cmd="/opt/lam/bin/lamboot"

############# Script option ########
#default trunc name of the submit script
name="q"
#template to add to the script name
template="_XXXXX"
#automatically naming of the script: yes/no
auto="no"
#add timing commands: yes/no
time="no"
#use scratch space by default: yes/no
scratch="no"
#base dir to scratch space
scratch_dir="/usr/scratch"
#file to create if jobs is finished
finish_file=""
#rebsumit the job until this file exists
resubmit_file=""
#file to source before running the command
extra_source=""
#default option if none are given on the command line
default_opts=""
#extra code to put in script after changing to the PWD and copy of files
# but before running the job
extra_begin_code=""
#extra code to put in script after running the job, but before copy back
extra_end_code=""

########### other options #####
#be quiet or not: yes/no
quiet="no"
#run in script mode: yes/no
scriptmode="no"
#wait for the jobs to finish: yes/no
wait="no"
#sec to wain in the --wait loop
sleeptime=900
#default email adress
#empty/none = no email, auto = leave it to queue where to send the mail
mail="none"
#header to show with --showjobs option
header="JOBS ON L.C.A.R.S. (thopXX)"
#shell to be used by default, none=bash
myshell="${SHELL##*/}"
#END DEFAULTS

#internal options not set in rcfile
#usage print out
usage="${0##*/} [OPTIONS] COMMAND [options]"
#internal for set command, empty for bash, but 'set' for tcsh
set=""
#was the connection already checked
checked_connection="no"
#user given script name
batchname=""
#user given log file name
logfile=""
#rc to read
rcfile="~/.${0##*/}rc"
#where to look for updates
branch=mpip
selfurl="http://job-tools.cj-overlay.googlecode.com/hg/qstart?r=$branch"
verurl="http://www.mpip-mainz.mpg.de/~junghans/job-tools/version.php"

qecho() {
  [[ "$quiet" = "no" ]] && echo -e "$*"
}

die() {
  [ -z "$1" ] || echo -e "$*" >&2
  [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$real_submit_hostname" ]; then
    ssh="bash -c"
  else
    if [ "$checked_connection" = "no" ]; then
      ssh $submit_host true || die "Heuristic connection check failed.
Change 'submit_host' variable in your setting file ($rcfile), which is now set to '$submit_host'.

To generate a setting file run:
   '${0##*/} --showdefaults > $rcfile'"
      checked_connection="yes"
    fi
    ssh="ssh $submit_host"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  [ -z "$message" ] || echo -e "$message"
}

check_job() {
  local runhost pid message
  [ -z "$1" ] && die "check_job: Missing argument"
  number_check "$1" "--checkjob"
  submit_host=$(show_column $1 2) || die
  real_submit_hostname="$submit_host"
  pid=$(show_column $1 3) || die
  message=$(run_on_host "ps -p $pid || true") || die
  if [ -z "${message/*$pid*}" ]; then
     qecho "Job $1: pid $pid on $runhost found"
     return 0
  else
    qecho "Job $1: pid $pid on $runhost NOT found"
    return 1
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  local runhost pid gpid pids
  [ -z "$1" ] && die "kill_job: Missing argument"
  number_check "$1" "--killjob"
  submit_host=$(show_column $1 2) || die
  real_submit_hostname="$submit_host"
  pid=$(show_column $1 3) || die
  run_on_host "ps --ppid $pid -o pid= | xargs kill" ||
    die "Could kill childs of pid $pid\nYou may want to run '${0##*/} --rmjob $1' to remove it from the joblist"
}

submit_job() {
  local message path
  [ -z "$1" ] && die "submit_job: missing argument"
  [ -f "$1" ] || die "Could not find $1"
  path="$(get_path_from_script $1)" || die
  message="$(run_on_host "cd $PWD;nohup $1 >/dev/null 2>&1 &")" || die
  qecho "$message"
}

print_jobids() {
  local job_id
  check_jobfile
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  for job_id in $(awk "(\$4 ~ /${1:0:8}/){print \$1}" $jobfile); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

get_version() {
  sed -ne 's/^#version[[:space:]]*\([^[:space:]]*\)[[:space:]]*,.*$/\1/p' $1 | sed -n '$p'
}

get_webversion() {
  local version
  if [ "$1" = "-q" ]; then
    version="$(wget -qO- "${selfurl}" | get_version)"
  else
    [ -z "$(type -p wget)" ] && die "wget not found"
    version="$(wget -qO- "${selfurl}" )" || die "self_update: wget fetch from $selfurl failed"
    version="$(echo -e "${version}" | get_version)"
    [ -z "${version}" ] && die "get_webversion: Could not fetch new version number"
  fi
  echo "${version}"
}

version_check() {
  [ -z "$(type -p wget)" ] && return 1
  [ "$(wget -q -O - "$verurl?name=${0##*/}&i=${USER}%40$HOSTNAME" 2>&1)" = "active" ] || return 1
  old_version="$(get_version $0)"
  [ "$1" = "-q" ] && new_version="$(get_webversion -q)" || new_version="$(get_webversion)"
  [ "$1" = "-q" ] || echo "Version of $selfurl is: $new_version"
  [ "$1" = "-q" ] || echo "Local Version: $old_version"
  expr "${old_version}" \< "${new_version}" > /dev/null
  return $?
}

self_update() {
  [ -z "$(type -p wget)" ] && die "wget not found"
  if version_check; then
    echo "I will try replace myself now with $selfurl (CTRL-C to stop)"
    sleep 5
    wget -O "${0}" "${selfurl}"
  else
    echo "No updated needed"
  fi
}

showhelp() {
 cat << eoh
    A script to start $header.
    It builds a very simple submit script (see -p options) and
    run them.

    $usage

    (later options overwrite previous ones, short options can be concatenated)

    SCRIPT OPTIONS:
    -n, --name NAME      Change trunc name of script
                         Default: $name
ADV     --batch NAME     Change name of the submit script
ADV                      Default:  \$(mktemp ${name}$template)
ADV                      (Argument is NAME+TEMPLATE)
ADV -l, --log NAME       Change name of the output file
ADV                      Default: log_"batch"
ADV     --template TEXT  Change template for mktemp
ADV                      Default: $template
ADV -a, --auto           Use first argument as name
ADV     --script         Will use the argument as base scripts and concatenate them
ADV                      (implies --nompi)
ADV -e, --emptytemplate  Same as --template ""
ADV -m, --mail NAME      send mail to NAME
ADV                      default: '$mail' (use 'auto' for automatic)
ADV -f, --finish NAME    Touches file NAME when succesfully finished
ADV -t, --time           Adds a date command before and after the command
    -p, --print          Only print the submit script (implies --nosubmit)
ADV     --nosubmit       Do submit the script, only create it (useful with --submit)
ADV     --submit   FILE  Submit the script FILE
ADV -w, --wait           Waits for the job to finish
ADV                      Exit status from existence of FILE from --finish or --resubmit
ADV     --sleeptime      Changes the sleeptime for --wait
ADV                      Default: $sleeptime
ADV     --shell NAME     Change the shell to use, script will sources ~/.XXXrc
ADV                      Default: $myshell
ADV     --source FILE    Source this file before run the progam

    QUEUE OPTIONS:
    -N                   Number of cpus
                         Possible: whatever
                         Default: $ncpus
ADV     --nompi          This is NOT a mpi job, so do NOT add mpirun (or equivalent)
ADV                      to the command line (for ncpus > 1) automatically
ADV     --runat HOST     Specify the host to run yourself


    JOBS OPTIONS:
        --showjobs        Show my jobs running
ADV     --checkjob JOB_ID Return true if job is still running (useful with -f)
ADV                       "while ${0##*/} -q --checkjob JOB_ID; do :; done"
ADV     --pcheck PATTERN  Return true if at least one job matching a pattern is still running
ADV                       PATTERN is search in the name column (useful with -f)
ADV                       "while ${0##*/} -q --pcheck NAME; do :; done"
        --showlog  JOB_ID Show logfile for running job with number JOB_ID
ADV     --showdir  JOB_ID Show pwd of simulation
ADV     --taillog  JOB_ID Same as --showlog but tail and follow
        --killjob  JOB_ID Kill job with number JOB_ID
ADV     --pkill PATTERN   Kill all jobs matching a pattern
ADV     --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
ADV     --checkjobs       Check if all jobs still exist
ADV     --rmjob    JOB_ID Remove job with JOB_ID from jobfile
ADV                       (useful after crash)
ADV     --header          Show info header

    COMMON OPTIONS:
ADV     --               End of options (if program starts with -)
ADV -q, --quiet          Be quiet
        --rcfile FILE    Extra setting file with defaults to read
                         Default: read only $rcfile if exist
ADV     --showdefaults   Show the default settings before reading $rcfile and the
ADV                      file given by --rcfile, useful to create own rcfile with:
ADV                      "${0##*/} --showdefaults > $rcfile"
ADV -v, --version        Prints version
        --selfupdate     Do a self update from googlecode
    -h, --help           Show short help message
        --longhelp       Show long help message

    Examples:
       ${0##*/} -8p sleep 30
       ${0##*/} -8p --nompi mpirun -np 8 sleep 30
       ${0##*/} --name gromacs mdrun -v
       ${0##*/} -8 mdrun
       ${0##*/} echo -e 'SOL\\\\nSOL' \| g_rdf -b 100 -n index.ndx

    Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_logs() {
  local path logfile
  [ -z "$2" ] && die "show_logfile: Missing argument"
  path=$(show_path $1) | die
  logfile=$(show_column $1 7) || die
  #add path if logfile does not contain /
  [ -n "${logfile/*\/*}" ] && logfile="${path}/$logfile"
  [ -r "$logfile" ] || die "Logfile ($logfile) not readable or not found!"
  $2 $logfile
  return $?
}

show_path() {
  local path
  path=$(show_column $1 4) || die
  [[ -d "$path" ]] || die "show_path: $path is not a dir"
  echo "$path"
  return $?
}

CJ
################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done

if [ -f $rcfile ]; then
  source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
  qecho "I have source $rcfile"
fi

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  --rcfile )
   rcfile="$2"
   source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
   qecho "I have source $rcfile"
   shift 2;;
  --showdefaults )
   sed -ne '/^#BEGIN DEFAULTS/,/^#END DEFAULTS/p' $0 | sed -e '1d' -e '$d' -e '/^[^#]/s/^/#/'
   exit 0;;
  -[0-9] )
   ncpus=${1#-}
   number_check "$ncpus" "$1"
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   submit="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpi_job="no"
   shift ;;
   --nosubmit | --norun)
   submit="no"
   shift ;;
   --submit)
   submit_job "$2"
   exit $? ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --scratch )
   scratch="yes"
   shift ;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -r | --resub | --resubmit)
   resubmit_file="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2 ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun | --nompi)
   mpi_job="no"
   shift ;;
   --walltime )
   wall_time="$2"
   [ -z "${wall_time/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
   shift 2;;
   --runat )
   hostname="$2"
   shift 2;;
   --runatnow )
   submit_opts="$submit_opts -l hostame=$2"
   shift 2;;
   --nooldnodes )
   no_old_nodes="yes"
   shift ;;
   --queue )
   specialq="$2"
   shift 2;;
   --showjobs )
   run_on_host "$job_status -u $USER"
   exit $?;;
   --alljobs )
   run_on_host "$job_status"
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --statjob )
   stat_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   queue_info $2
   exit $?;;
   --showdir )
   show_path "$2"
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tailf"
   exit $?;;
  -v | --version)
   echo "${0##*/}, version $(get_version $0) ($branch branch) by C. Junghans"
   exit 0;;
  --selfupdate)
   self_update
   exit $?;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp | sed -e '/^ADV /d' -e 's/^    //'
   exit 0;;
  --longhelp)
   showhelp | sed -e 's/^ADV/   /' -e 's/^    //'
   exit 0;;
  --)
   shift
   break;;
  *)
   die "Unknown option '$1'";;
 esac
done

if version_check -q; then
  x=${0##*/}; x=${x//?/#}
  echo "##################################$x"
  echo "# Your version of ${0##*/} is obsolete ! #"
  echo "# Please run '${0##*/} --selfupdate'     #"
  echo "##################################$x"
  unset x
fi

if [ -z "$1" ]; then
  [ -z "${default_opts}" ] && die "Missing program name (try --help)"
  set -- ${default_opts}
fi

[[ $auto = "yes" ]] && name=${1##*/}

if [ -z "$batchname" ]; then
  #template contains no 'X'
  if [ -z "${template//[^X]}" ]; then
    batchname="${name}"
  elif [ -n "$(type -p mktemp)" ]; then
    batchname=$(mktemp -u ${name}${template}) || die "mktemp could not generate file"
  else
    echo No mktemp found >&2
    l=${template//[^X]}
    l=${#l}
    t2=${template}
    batchname=${0}
    while [ -f ${batchname} ]; do
      for ((i=0;i<$l;i++)); do
        t2=${t2/X/${RANDOM:0:1}}
      done
      batchname=${name}${t2}
    done
  fi
  touch ${batchname}
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "submit script: $batchname"
  qecho "logfile: $logfile"
fi

if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ]; then
  echo "#! /bin/bash" > $batchname
elif [ "$myshell" = "zsh" ]; then
  echo "#! /usr/bin/zsh" > $batchname
elif [ "$myshell" = "tcsh" ]; then
  echo "#! /bin/tcsh" > $batchname
  set="set "
else
  die "Unsupported shell"
fi

queue_name="$(cpunr_to_queuename $ncpus)" || die

cat <<EOF >> $batchname
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using $($0 --version)

#sge options
#$ -cwd
#$ -j y
#$ -o $logfile
#$ -l h_rt=${wall_time}
#$ -q ${queue_name}
EOF

[ -n "$(extra_queue_header $ncpus)" ] && extra_queue_header $ncpus >> $batchname
[ -n "$hostname" ] && echo "#$ -l hostname=${hostname}" >> $batchname

#To mail or not to mail
if [ -z "$mail" ] || [ "$mail" = "none" ]; then
  echo "#$ -m n" >> $batchname
else
  echo "#$ -m e" >> $batchname
  [ "$mail" = "auto" ] || echo "#$ -M $mail" >> $batchname
fi

if [ "$myshell" = "bash" ]; then
  echo "#$ -S /bin/bash" >> $batchname
  [ -f ~/.bashrc ] && sh_source="source ~/.bashrc"
elif [ "$myshell" = "zsh" ]; then
  echo "#$ -S /usr/bin/zsh" >> $batchname
  [ -f ~/.zshrc ] && sh_source="source ~/.zshrc"
elif [ "$myshell" = "tcsh" ]; then
  echo "#$ -S /bin/tcsh" >> $batchname
  if [ -f ~/.tcshrc ]; then
    sh_source="source ~/.tcshrc"
  elif [ -f ~/.cshrc ]; then
    sh_source="source ~/.cshrc"
  fi
elif [ "$myshell" = "none" ]; then
  echo "#$ -S /bin/bash" >> $batchname
fi

cat <<EOF >>$batchname

${sh_source}

cd $PWD
echo Hi, I am job \$JOB_ID on \$HOSTNAME in \$PWD

EOF
[ -n "$extra_source" ] && echo "source $extra_source" >> $batchname
if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname
#Copy the needed files
${set}olddir=\$PWD
${set}newdir=$scratch_dir/\$USER/\$JOB_ID
mkdir -p \$newdir || exit 1
EOF
[ -n "$filelist" ] && cat <<EOF >>$batchname
echo Copy needed files:
echo $filelist
cp -r $filelist \$newdir
echo finished copying files
EOF
echo 'cd $newdir' >> $batchname
fi

if [ -n "${extra_begin_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra begin code
${extra_begin_code}
#END of extra begin code
EOF
fi

echo echo Starting simulation >> $batchname

[[ "$time" = "yes" ]] && echo date >> $batchname
[[ $ncpus -ne 1 ]] && echo "pgrep lamd > /dev/null || $lamboot_cmd" >> $batchname
if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname
  done
  cmdline=""
else
  #do not add quotes to the first argument
  cmdline="$1"
  shift
  for i in "$@"; do
    [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
  done
  if [ "$mpi_job" = "yes" ] && [ $ncpus -gt 1 ]; then
    cmdline="$mpirun_cmd -np $ncpus $cmdline"
  fi
fi

cat <<EOF >>$batchname
$cmdline
${set}result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

if [ -n "${extra_end_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra end code
${extra_end_code}
#END of extra end code
EOF
fi

if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname

#Copy files back
echo Copy back files:
echo *
cp -ru * \$olddir
echo finished copying files
cd \$olddir
echo Removing scratch dir
[ \$result -eq 0 ] && rm -fr \$newdir
EOF
fi

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ -n "$resubmit_file" ]; then
  [ -f "$resubmit_file" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $job_submit in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f '$resubmit_file' ] && $job_submit $PWD/$batchname" >> $batchname
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && [ -f $resubmit_file ] && touch $finish_file" >> $batchname
else
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && touch '$finish_file'" >> $batchname
fi

if [ "$submit" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && qecho "to submit the script run: '${0##*/} --submit $batchname'"
  exit 0
fi

submit_job $batchname

if [ "$wait" = "yes" ]; then
  qecho "Waiting for $batchname to finish"
  quiet="yes"
  while pcheck_job $batchname; do
    sleep $sleeptime;
  done
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resubmit_file}" ]] && [[ ! -f "$resubmit_file" ]] && exit 1
  exit 0
fi
