#! /bin/bash

#version 0.1   ,29.09.08 -- initial version
#version 0.2   ,29.09.08 -- added scratch option
#version 0.3   ,30.09.08 -- added template options
#version 0.4   ,02.10.08 -- added job options
#version 0.4.1 ,02.10.08 -- bugs fix in exit code
#version 0.4.2 ,02.10.08 -- added --queueinfo
#version 0.4.3 ,05.10.08 -- bug in checkjob with zero msg
#version 0.5.0 ,07.10.08 -- consitency with start
#version 0.5.1 ,08.10.08 -- notemplate is now emptytemplate
#version 0.5.2 ,08.10.08 -- corrected help
#version 0.5.3 ,08.10.08 -- bug in short opts
#version 0.5.4 ,08.10.08 -- added --header
#version 0.5.5 ,11.11.08 -- fixed bug with --print
#version 0.5.6 ,17.11.08 -- added --pcheck
#version 0.5.7 ,17.11.08 -- added --resub
#version 0.5.8 ,21.11.08 -- added resub example
#version 0.5.9 ,02.12.08 -- remove perl depend, cut patterns to 8 chars
#version 0.5.10,26.02.09 -- added some note and --shell option
#version 0.6.0, 02.03.09 -- --scratch should work now
#version 0.6.1, 07.04.09 -- make it work with tcsh + bugfix in pe for 2cpus
#version 0.6.2, 14.05.09 -- added zsh support, thx to Konstantin
#version 0.7.0, 14.05.09 -- added --wait
#version 0.7.1, 24.08.09 -- added --runat option
#version 0.7.2, 24.08.09 -- --(p)checkjob will mention jobs in error state
#version 0.7.3, 26.08.09 -- improved shell related stuff
#version 0.7.4, 02.09.09 -- fixed small bug in --auto, added --runatnow
#version 0.7.5, 14.09.09 -- add header in batch script
#version 0.8.0, 18.09.09 -- tcsh support and --script option
#version 0.8.1, 21.09.09 -- solved a tcsh issue (thx to biswa)

#defaults
usage="${0##*/} [OPTIONS] COMMAND [options]"
qsubmit="qsubmit"
mpirun="yes"
hostname=""
qsub_opts=""
mpicmd="/opt/lam/bin/mpirun"
sge_path="/opt/SGE/bin/lx26-amd64"
qsub="$sge_path/qsub"
qstat="$sge_path/qstat"
qdel="$sge_path/qdel"
runhost="thop02"
ncpus=1
name="q"
quiet="no"
auto="no"
run="yes"
batchname=""
logfile=""
finish_file=""
time="no"
scratch_dir="/usr/scratch"
scratch="no"
template="_XXXXX"
mail="$USER@mpip-mainz.mpg.de"
header="JOBS ON L.C.A.R.S. (thopXX)"
resub=""
myshell="${SHELL##*/}"
wait="no"
sleeptime=900
scriptmode="no"
set=""

die() {
  echo "$*" >&2
  exit 1
}

clean_up() {
  [[ -n "$batchname" ]] && \
    [[ "$batchname" != "/dev/stdout" ]] && \
    [[ -f "$batchname" ]] && \
    rm $batchname
}
trap "clean_up" 1 2 3 6 15

if [ "${SHELL##*/}" = "bash" ]  || [ "${SHELL##*/}" = "zsh" ]; then
  sh_cmd="export SGE_ROOT=/opt/SGE"
elif [ "${SHELL##*/}" = "tcsh" ]; then
  sh_cmd="setenv SGE_ROOT /opt/SGE"
else
  die "Your shell ($SHELL) is not supported yet"
fi

check_job() {
message=$(ssh $runhost "${sh_cmd};$qstat -u $USER") || \
  die "ssh $runhost '${sh_cmd};$qstat -u $USER' failed"
if [ -z "$(echo -e "$message" | awk "(\$1==$1){print \$0}")" ]; then
  [[ "$quiet" = "yes" ]] || echo "Job '$1' on $runhost NOT found"
  exit 1
elif [ -z "$(echo -e "$message" | awk "(\$1==$1)&&(\$5 !~ /E/){print \$0}")" ]; then
  [[ "$quiet" = "yes" ]] || echo "Job '$1' on $runhost in error state"
  exit 1
else
  [[ "$quiet" = "yes" ]] || echo "Job '$1' on $runhost found"
  exit 0
fi
}

check_shell() {
if [ "$myshell" = "none" ] || \
   [ "$myshell" = "bash" ] || \
   [ "$myshell" = "tcsh" ] || \
   [ "$myshell" = "zsh" ]; then
  :
else
  die "Your shell is not supported yet"
fi
}

pcheck_job() {
[ -n "$1" ] || die "No pattern given"
message=$(ssh $runhost "${sh_cmd};$qstat -u $USER") || \
  die "ssh $runhost '${sh_cmd};$qstat -u $USER' failed"
if [ -z "$(echo -e "$message" | awk "(\$3 ~ /${1:0:8}/){print \$0}")" ]; then
  [[ "$quiet" = "yes" ]] || echo "Job with name matching '${1:0:8}' on $runhost NOT found"
  exit 1
elif [ -z "$(echo -e "$message" | awk "(\$3 ~/${1:0:8}/)&&(\$5 !~ /E/){print \$0}")" ]; then
  [[ "$quiet" = "yes" ]] || echo "Job with name matching '${1:0:8}' on $runhost in error state"
  exit 1
else
  [[ "$quiet" = "yes" ]] || echo "Job with name matching '${1:0:8}' on $runhost found"
  exit 0
fi
}

kill_job() {
ssh $runhost "${sh_cmd};$qdel $1" || \
  die "ssh $runhost '${sh_cmd};$qdel $1' failed"
}

pkill_job() {
[ -n "$1" ] || die "Expect a pattern"
message=$(ssh $runhost "${sh_cmd};$qstat -u $USER") || \
  die "ssh $runhost '${sh_cmd};$qstat -u $USER' failed"
for job_id in $(echo -e "$message" | awk "(\$3 ~ /${1:0:8}/){print \$1}"); do
  $0 --killjob $job_id
done
}

number_check(){
number="$1"
option="$2"
[ -z "$number" ] && die "Missing number in $option"
[ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

queue_info() {
if [ $1 -eq 1 ]; then
  queue="all.q"
elif [ $1 -eq 2 ]; then
  queue="dual.q"
elif [ $1 -eq 8 ]; then
  queue="octal.q"
else
  die "Number of cpus unsupported"
fi
ssh $runhost "${sh_cmd};$qstat -q $queue" || \
  die "ssh $runhost '${sh_cmd};$qstat -q $queue' failed"
}

showhelp() {
 cat << eoh
A script to start a job on the cluster.
It builds a very simple qsub script (see -p options) and
run it.

$usage

SCRIPT OPTIONS:
-n, --name NAME      Change global name of script
                     Default: $name
    --batch NAME     Change name of the qsub script
                     Default:  \$(mktemp ${name}$template)
                     (Argument is NAME+TEMPLATE)
-l, --log NAME       Change name of the output file
                     Default: log_"batch"
    --template TEXT  Change template for mktemp
                     Default: $template
-a, --auto           Use first argument as name
    --script         Will use the argument as base scripts and concatenate them
                     (implies --nompirun)
-e, --emptytemplate  Same as --template ""
-m, --mail NAME      send mail to NAME
                     default: '$mail'
-x, --nomail         will not use mail function
-f, --finish NAME    Create a file NAME when succesfully finished
                     Usefull with --checkjob and "[[ -f NAME ]] || exit 1"
-t, --time           Adds a date command before and after the command
-p, --print          Only print the qsub script (implies --norun)
    --norun          Do NOT run the qsub script in the end
-r, --resub FILE     Resub the script if exit status was 0 and FILE not exist
-w, --wait           Waits for the job to finish
                     Exit status from existence of FILE from --finish or --resub
    --sleeptime      Changes the sleeptime for --wait
                     Default: $sleeptime
    --shell NAME     Change the shell to use, script will sources ~/.XXXrc   
                     Default: $myshell
    --scratch        Use scratch on "$scratch_dir/\$USER/"
    --needed FILES   Give the files needed to be copy to the scratch dir to
                     run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
                     (implies --scratch)

MPI OPTIONS:
-N                   Number of cpus (also determines the queue)
                     Default: $ncpus
    --nompirun       Do NOT add mpirun automatically to the command line for ncpus > 1
    --runat HOST     Specify the host to run yourself
    --runatnow HOST  like --runat, but one do it one time, not after the resub


JOBS OPTIONS:
    --showjobs        Show jobs running (on $runhost)
    --checkjob JOB_ID Return true if job is still running (useful with --f)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --pcheck PATTERN  Return true if job is still running (useful with --f)
                      PATTERN is search in the name column
                      "while ${0##*/} -q --checkjob NAME; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --taillog  JOB_ID Same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with NUMBER
    --pkill PATTERN   Kill all jobs matching a pattern
    --queueinfo NR    Show info about some queue [1|2|8]
    --header          Show info header

COMMON OPTIONS:
-q, --quiet          Be quiet
-v, --version        Prints version
-h, --help           Show this help message

Notes for scratch space :
------------------------
-The usage of the scratch space is still at the beginning of testing,
 use it with care! 
-You may add the files to copy there with --needed or use "--needed '*'",
 if your job has a separate dir.
-Give the full path of binary or add itself to --needed and use "./", if
 it is not in your PATH variable.
-Remember to subtract the time needed to copy the files !

Examples:
   ${0##*/} -8p sleep 30
   ${0##*/} -8p --nompirun mpirun -np 8 sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} -8 --needed traj.trr mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"
   ${0##*/} -8 --resub confout.gro  mdrun -append -cpi state.cpt -maxh 36
            (Note: -cpi is smart, the first time mdrun will start normal!)         
   ${0##*/} -8 --needed '*' --resub confout.gro  mdrun -append -cpi state.cpt -maxh 35
            (Note: --needed '*' needs a separate dir for the simulation!)

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_jobs() {
ssh $runhost "${sh_cmd};$qstat -u $USER" || \
  die "ssh $runhost '${sh_cmd};$qstat -u $USER' failed"
}

show_logs() {
message=$(ssh $runhost "${sh_cmd};$qstat -r -j $1") || \
  die "ssh $runhost '${sh_cmd};$qstat -r -j $1' failed"
path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
logfile=$(echo -e "$message" | awk '/^stdout_path_list:/{ print $2}')
$2 $path/$logfile
}
################################################
############## Main Program ####################
################################################
shopt -s extglob

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  -[0-9] )
   ncpus=${1#-}
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   run="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpirun="no"
   shift ;;
   --norun )
   run="no"
   shift ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --scratch )
   scratch="yes"
   shift ;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -x | --nomail)
   mail=''
   shift ;;
   -r | --resub)
   resub="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2 ;;
   --nompirun )
   mpirun="no"
   shift ;;
   --runat )
   hostname="$2"
   shift 2;;
   --runatnow )
   qsub_opts="$qsub_opts -l hostame=$2"
   shift 2;;
   --showjobs )
   show_jobs
   exit 0;;
   --killjob )
   number_check "$2" "--killjob"
   kill_job $2
   exit 0;;
   --pkill )
   pkill_job "$2"
   exit 0;;
   --checkjob )
   number_check "$2" "--checkjob"
   check_job $2
   exit 0;;
   --pcheck )
   pcheck_job $2
   exit 0;;
   --queueinfo )
   number_check "$2" "--queueinfo"
   queue_info $2
   exit 0;;
   --showlog )
   number_check "$2" "--showlog"
   show_logs "$2" "cat"
   exit 0;;
   --taillog )
   number_check "$2" "--showlog"
   show_logs "$2" "tailf"
   exit 0;;
  -v | --version)
   echo ${0##*/}, $(sed -ne 's/^#\(version.*\) -- .*$/\1/p' $0 | sed -n '$p') by C. Junghans
   exit 0;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  *)
   die "Unknown option '$1'"
   exit 0;;
 esac
done

[ -z "$1" ] && die "Missing program name (try --help)"
check_shell

[[ $auto = "yes" ]] && name=$1


if [ -z "$batchname" ]; then
  if [ -n $(type -p mktemp) ]; then
    batchname=$(mktemp ${name}${template}) || { echo mktemp could not generate file >&2; exit 1; }
  else
    echo No mktemp found >&2
    batchname=$name
  fi
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$quiet" = "no" ] && [ "$batchname" != "/dev/stdout" ]; then
  echo qsubscript: $batchname
  echo logfile: $logfile
fi

#TCSH changes go here
#first line, source, for loop?
if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ]; then
  echo "#! /bin/bash" > $batchname
elif [ "$myshell" = "zsh" ]; then
  echo "#! /usr/bin/zsh" > $batchname
elif [ "$myshell" = "tcsh" ]; then
  echo "#! /bin/tcsh" > $batchname
  set="set "
else
  die "Unsupported shell"
fi
cat <<EOF >>$batchname
#This script is generated by $USER@$HOSTNAME
#on $(date)
#using $($0 --version)

#sge options
EOF
if [ $ncpus -eq 1 ]; then
  echo "#$ -q all.q" >> $batchname
elif [ $ncpus -eq 2 ]; then
  echo "#$ -q dual.q" >> $batchname
  echo "#$ -pe lammpi2cpu 2" >> $batchname
elif [ $ncpus -eq 8 ]; then
  echo "#$ -q octal.q" >> $batchname
  echo "#$ -pe lammpi8cores 8" >> $batchname
else
  die "Number of cpus unsupported"
fi

if [ -n "$hostname" ]; then
  echo "#$ -l hostname=${hostname}" >> $batchname
fi
  
if [ -z "$mail" ]; then
  echo "#$ -m n" >> $batchname
else
  echo "#$ -m e" >> $batchname
  echo "#$ -M $mail" >> $batchname
fi

cat <<EOF >>$batchname
#$ -cwd
#$ -j y
#$ -o $logfile

EOF

[[ "$myshell" = "bash" ]] && echo "source ~/.bashrc" >> $batchname
[[ "$myshell" = "zsh" ]] && echo "source ~/.zshrc" >> $batchname
[[ "$myshell" = "tcsh" ]] && echo "source ~/.cshrc" >> $batchname

cat <<EOF >>$batchname

cd $PWD
echo Hi, I am job \$JOB_ID on \$HOSTNAME

EOF

if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname
#Copy the needed files 
${set}olddir=\$PWD
echo Copy needed files:
echo $filelist
${set}newdir=$scratch_dir/\$USER/\$JOB_ID
mkdir -p \$newdir || exit 1
cp $filelist \$newdir
echo finished copying files
cd \$newdir

EOF
fi

echo echo Starting simulation >> $batchname
[[ "$time" = "yes" ]] && echo date >> $batchname
if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname 
  done
elif [ "$mpirun" = "no" ] || [ $ncpus -eq 1 ]; then
  echo "$*" >> $batchname
else
  echo "$mpicmd -np $ncpus $*" >> $batchname
fi
echo "result=\$?" >> $batchname

if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname

#Copy files back  
echo Copy back files:
echo *
cp -u * \$olddir
echo finished copying files
cd \$olddir
echo Removing scratch dir
[ \$result -eq 0 ] && rm -fr \$newdir
EOF
fi
[[ "$time" = "yes" ]] && echo date >> $batchname
if [ -n "$resub" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $qsub in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f $resub ] && { $qsub $PWD/$batchname; exit 0; }" >> $batchname
fi
[[ -z "$finish_file" ]] || echo "[ \$result -eq 0 ] && touch $finish_file" >> $batchname

if [ "$run" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && echo "ssh $runhost '${sh_cmd};cd $PWD;$qsub $qsub_opts $batchname'"
  exit 0
fi

if [ -n "${sh_cmd}" ]; then
  ssh $runhost "${sh_cmd};cd $PWD;$qsub $qsub_opts $batchname" || \
    die "ssh $runhost '${sh_cmd};cd $PWD;$qsub $qsub_opts $batchname' failed"
else
  echo "Your shell ($SHELL) is not supported yet" >&2
  echo "Logon $runhost and do:" >&2
  echo " cd $PWD" >&2
  echo " $qsub $batchname" >&2
  exit 1
fi

if [ "$wait" = "yes" ]; then
  echo Waiting for $batchname to finish
  while $0 -q --pcheck $batchname; do
    sleep $sleeptime;
  done
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resub}" ]] && [[ ! -f "$resub" ]] && exit 1
  exit 0
fi
