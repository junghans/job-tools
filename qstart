#! /bin/bash
#
# C.Junghans
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#version 0.1   ,29.09.08 -- initial version
#version 0.2   ,29.09.08 -- added scratch option
#version 0.3   ,30.09.08 -- added template options
#version 0.4   ,02.10.08 -- added job options
#version 0.4.1 ,02.10.08 -- bugs fix in exit code
#version 0.4.2 ,02.10.08 -- added --queueinfo
#version 0.4.3 ,05.10.08 -- bug in checkjob with zero msg
#version 0.5.0 ,07.10.08 -- consitency with start
#version 0.5.1 ,08.10.08 -- notemplate is now emptytemplate
#version 0.5.2 ,08.10.08 -- corrected help
#version 0.5.3 ,08.10.08 -- bug in short opts
#version 0.5.4 ,08.10.08 -- added --header
#version 0.5.5 ,11.11.08 -- fixed bug with --print
#version 0.5.6 ,17.11.08 -- added --pcheck
#version 0.5.7 ,17.11.08 -- added --resub
#version 0.5.8 ,21.11.08 -- added resub example
#version 0.5.9 ,02.12.08 -- remove perl depend, cut patterns to 8 chars
#version 0.5.10,26.02.09 -- added some note and --shell option
#version 0.6.0, 02.03.09 -- --scratch should work now
#version 0.6.1, 07.04.09 -- make it work with tcsh + bugfix in pe for 2cpus
#version 0.6.2, 14.05.09 -- added zsh support, thx to Konstantin
#version 0.7.0, 14.05.09 -- added --wait
#version 0.7.1, 24.08.09 -- added --runat option
#version 0.7.2, 24.08.09 -- --(p)checkjob will mention jobs in error state
#version 0.7.3, 26.08.09 -- improved shell related stuff
#version 0.7.4, 02.09.09 -- fixed small bug in --auto, added --runatnow
#version 0.7.5, 14.09.09 -- add header in batch script
#version 0.8.0, 18.09.09 -- tcsh support and --script option
#version 0.8.1, 21.09.09 -- solved a tcsh issue (thx to biswa)
#version 0.8.2, 24.09.09 -- solved another tcsh issue (thx to biswa)
#version 0.8.3, 02.10.09 -- moved to thop100, added --getjid and clean up
#version 0.8.4, 02.11.09 -- fixed a bug in --pcheck
#version 0.8.5, 03.11.09 -- fixed another bug in --pcheck + pcheck help
#version 0.8.6, 24.11.09 -- added --showdir + better output in logfile
#version 0.8.7, 07.12.09 -- exec lamboot if no lamd is running
#version 0.8.8, 04.01.10 -- add -- option
#version 0.9.0, 06.01.10 -- fixed a bug in emptyfile list (thx to sasha)
#version 0.9.1, 07.01.10 -- clean up, added run_on_host
#version 0.9.2, 11.01.10 -- added --source option + cmdline in script
#version 0.9.3, 01.02.10 -- rm batchname, when crashing, resub warning
#version 0.9.4, 04.02.10 -- added some checks for .*shrc files + removed sh_cmd
#version 0.9.5, 10.02.10 -- make resub work in tcsh (thx to christine)
#version 0.9.6, 23.02.10 -- added #S in script, fixed --norun
#version 0.9.7, 27.04.10 -- fixed a type in #S
#version 0.9.8, 21.06.10 -- make --wait work with --resub (thx to ananya)
#version 0.9.9, 07.07.10 -- added --alljobs (thx to victor)
#version 0.9.10,07.07.10 -- added connection check
#version 1.0.0 ,13.08.10 -- major variable renaming added --rcfile option
#version 1.0.1 ,16.08.10 -- added --nooldnodes and extra_XXX_code rc options
#version 1.0.2 ,19.08.10 -- assigned test.q if walltime <= 20min
#version 1.0.3 ,24.08.10 -- added --selfupdate
#version 1.0.4 ,27.08.10 -- fixed a bug in --submit
#version 1.0.5 ,07.12.10 -- added --queue option
#version 1.1.0 ,20.12.10 -- added default version check
#version 1.1.1 ,19.01.11 -- nodes above thop82 are not in thinc queue
#version 1.1.2 ,19.01.11 -- fixed a bug when args were quoted
#version 1.1.3 ,20.01.11 -- bug in version 1.1.2 due to wrong logic
#version 1.1.4 ,28.01.11 -- nomail is now default
#version 1.1.5 ,04.02.11 -- updated help message
#version 1.1.6 ,04.02.11 -- added longhelp message
#version 1.1.7 ,10.02.11 -- back to thop01 as default submit_host
#version 1.1.8 ,17.02.11 -- fixed a bug when sourcing rcfile
#version 1.2.0 ,14.03.11 -- added --cpback
#version 1.2.1 ,21.04.11 -- fixed a bug in mail=auto
#version 1.2.2 ,01.08.11 -- fixed a bug in mktemp
#version 1.2.3 ,15.08.11 -- added script variables
#version 1.3.0 ,21.09.11 -- added --ignore-obsolete and check for defaults

#############################################################
# NEVER EVEN change settings below, but in your ~/.qstartrc #
# because --selfupdate will overwrite it !                  #
#############################################################

#BEGIN DEFAULTS
#defaults options, uncomment and change only the lines you really need to change
#keep it in bash style, source must work on this file

############## QUEUE stuff #########
#path to queue utils need later on
queue_path="/opt/SGE/bin/lx26-amd64"

#command to submit a job
job_submit="$queue_path/qsub"
#command to get status
job_status="$queue_path/qstat"
#command to cancel/delete a job
job_kill="$queue_path/qdel"
#command to cancel/delete a job
job_info="$queue_path/qconf"
#extra options for submit
submit_opts=""
#name of the host, where to submit the jobs
#maybe create an sshalias
submit_host="thop01"
#the real hostname ($HOSTNAME), when logon submit_host
real_submit_hostname="$submit_host"
#submit the script by default: yes/no
submit="yes"
#default number of cpus to use
ncpus=1
#default wall clock time
wall_time="36:00:00"
#on which node to run by default, empty = no default
hostname=""
#overwrite the queue to be used this, empty = normal queue
specialq=""
#no old node, will only use nodes >=thop63
no_old_nodes="no"

########### MPI stuff ###############
#should mpirun (or equivalent) be added: yes/no
mpi_job="yes"
#the command to add for mpi jobs
mpirun_cmd="/opt/lam/bin/mpirun"
#lamboot command
lamboot_cmd="/opt/lam/bin/lamboot"

############# Script option ########
#default trunc name of the submit script
name="q"
#template to add to the script name
template="_XXXXX"
#automatically naming of the script: yes/no
auto="no"
#add timing commands: yes/no
time="no"
#use scratch space by default: yes/no
scratch="no"
#base dir to scratch space
scratch_dir="/usr/scratch"
#file to create if jobs is finished
finish_file=""
#rebsumit the job until this file exists
resubmit_file=""
#file to source before running the command
extra_source=""
#default option if none are given on the command line
default_opts=""
#extra code to put in script after changing to the PWD and copy of files
# but before running the job
extra_begin_code=""
#extra code to put in script after running the job, but before copy back
extra_end_code=""

########### other options #####
#be quiet or not: yes/no
quiet="no"
#run in script mode: yes/no
scriptmode="no"
#wait for the jobs to finish: yes/no
wait="no"
#sec to wain in the --wait loop
sleeptime=900
#default email adress
#empty/none = no email, auto = leave it to queue where to send the mail
mail="none"
#header to show with --showjobs option
header="JOBS ON L.C.A.R.S. (thopXX)"
#shell to be used by default, none=bash
myshell="${SHELL##*/}"
#ignore if we are using a obsolete version
ignore_obsolete="no"
#END DEFAULTS

#internal options not set in rcfile
#usage print out
usage="${0##*/} [OPTIONS] COMMAND [options]"
#internal for set command, empty for bash, but 'set' for tcsh
set=""
#was the connection already checked
checked_connection="no"
#if the job submit directly
direct_submit="no"
#user given script name
batchname=""
#user given log file name
logfile=""
#rc to read
rcfile="~/.${0##*/}rc"
#where to look for updates
branch=mpip
selfurl="http://job-tools.cj-overlay.googlecode.com/hg/qstart?r=$branch"

qecho() {
  [[ "$quiet" = "no" ]] && echo -e "$*"
}

die() {
  [ -z "$1" ] || echo -e "$*" >&2
  [ "$direct_submit" = "no" ] && [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchfile $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$real_submit_hostname" ]; then
    ssh="bash -c"
  else
    if [ "$checked_connection" = "no" ]; then
      ssh $submit_host true || die "Heuristic connection check failed.
Change 'submit_host' variable in your setting file ($rcfile), which is now set to '$submit_host'.

To generate a setting file run:
   '${0##*/} --showdefaults > $rcfile'"
      checked_connection="yes"
    fi
    ssh="ssh $submit_host"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  [ -z "$message" ] || echo -e "$message"
}

check_job() {
  local message
  number_check "$1" "--checkjob"
  message=$(run_on_host "$job_status -u $USER") || die
  if [ -z "$(echo -e "$message" | awk "(\$1==$1){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host NOT found"
    return 1
  elif [ -z "$(echo -e "$message" | awk "(\$1==$1)&&(\$5 !~ /E/){print \$0}")" ]; then
    qecho "Job '$1' on $submit_host in error state"
    return 1
  else
    qecho "Job '$1' on $submit_host found"
    return 0
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then
    qecho "No jobs matching $1 found"
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  number_check "$1" "--killjob"
  run_on_host "$job_kill $1"
  return $?
}

stat_job() {
  number_check "$1" "--statjob"
  run_on_host "$job_status -j $1"
  return $?
}

submit_job() {
  local message path
  [ -z "$1" ] && die "submit_job: missing argument"
  [ -f "$1" ] || die "Could not find $1"
  path="$(get_path_from_script $1)" || die
  message="$(run_on_host "cd $path;$job_submit $submit_opts $1")" || die
  qecho "$message"
}

print_jobids() {
  local message job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  message=$(run_on_host "$job_status -u $USER") || die
  for job_id in $(echo -e "$message" | awk "(\$3 ~ /${1:0:8}/){print \$1}"); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

extra_queue_header() {
  [ -z "$1" ] && die "extra_queue_header: Missing argument"
  if [ $1 -eq 2 ]; then
    echo "#$ -pe lammpi2cpu 2"
  elif [ $1 -eq 8 ]; then
    echo "#$ -pe lammpi8cores 8"
  fi
}

cpunr_to_queuename() {
  local queue secs
  [ -z "$1" ] && die "cpunr_to_queuename: Missing argument"
  secs=$(walltime_to_sec $wall_time) || die
  [ $secs -gt 129600 ] && die "Wall time bigger than 36h is not possible"
  if [ -n "$specialq" ]; then
    queue="$specialq"
  elif [ $1 -eq 1 ]; then
    queue="all.q"
  elif [ $1 -eq 2 ]; then
    queue="dual.q"
  elif [ $1 -eq 8 ]; then
    queue="octal.q"
  else
    die "Do not know how to handle this Number of cpus '$1'"
  fi
  if [ "$no_old_nodes" = "yes" ]; then
    expand_queue $queue
  else
    # test.q has max 20min and runs on an old node
    if [ $secs -le 1200 ] && [ $1 -eq 1 ] ; then
      echo test.q
    else
      echo $queue
    fi
  fi
}

walltime_to_sec() {
  local secs wall
  [ -z "$1" ] && die "walltime_to_sec: Missing argument"
  [ -z "${1/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
  wall="$1"
  secs=${wall##*:}
  wall=${wall%:??}
  secs=$(( $secs + 60*${wall##*:} ))
  wall=${wall%:??}
  secs=$(( $secs + 3600*${wall##*:} ))
  echo "$secs"
}

expand_queue(){
  local i max=82
  [ -z "$1" ] && die "expand_queue: Missing argument"
  for ((i=63;i<$max;i++)); do
    echo -n "${1}@thop${i},"
  done
  echo ${1}@thop$max
}

queue_info() {
  local queue
  if [ -n "$1" ]; then
    number_check "$1" "--queueinfo"
    queue="$(cpunr_to_queuename "$1")" || die
    run_on_host "$job_info -sq $queue"
  else
    run_on_host "$job_info -sql"
  fi
  return $?
}

get_version() {
  sed -ne 's/^#version[[:space:]]*\([^[:space:]]*\)[[:space:]]*,.*$/\1/p' $1 | sed -n '$p'
}

get_webversion() {
  local version
  if [ "$1" = "-q" ]; then
    version="$(wget -qO- "${selfurl}" | get_version)"
  else
    [ -z "$(type -p wget)" ] && die "wget not found"
    version="$(wget -qO- "${selfurl}" )" || die "self_update: wget fetch from $selfurl failed"
    version="$(echo -e "${version}" | get_version)"
    [ -z "${version}" ] && die "get_webversion: Could not fetch new version number"
  fi
  echo "${version}"
}

version_check() {
  [ -z "$(type -p wget)" ] && return 1
  old_version="$(get_version $0)"
  [ "$1" = "-q" ] && new_version="$(get_webversion -q)" || new_version="$(get_webversion)"
  [ "$1" = "-q" ] || echo "Version of $selfurl is: $new_version"
  [ "$1" = "-q" ] || echo "Local Version: $old_version"
  expr "${old_version}" \< "${new_version}" > /dev/null
  return $?
}

self_update() {
  [ -z "$(type -p wget)" ] && die "wget not found"
  if version_check; then
    echo "I will try replace myself now with $selfurl (CTRL-C to stop)"
    sleep 5
    wget -O "${0}" "${selfurl}"
  else
    echo "No update needed"
  fi
}

showhelp() {
 cat << eoh
    A script to start $header.
    It builds a very simple submit script (see -p options) and
    run them.

    $usage

    (later options overwrite previous ones, short options can be concatenated)

    SCRIPT OPTIONS:
    -n, --name NAME      Change trunc name of script
                         Default: $name
ADV     --batch NAME     Change name of the submit script
ADV                      Default:  \$(mktemp ${name}$template)
ADV                      (Argument is NAME+TEMPLATE)
ADV -l, --log NAME       Change name of the output file
ADV                      Default: "batch".log
ADV     --template TEXT  Change template for mktemp
ADV                      Default: $template
ADV -a, --auto           Use first argument as name
ADV     --script         Will use the argument as base scripts and concatenate them
ADV                      (implies --nompi)
ADV -e, --emptytemplate  Same as --template ""
ADV -m, --mail NAME      send mail to NAME
ADV                      default: '$mail' (use 'auto' for automatic)
ADV -f, --finish NAME    Touches file NAME when succesfully finished
ADV -t, --time           Adds a date command before and after the command
    -p, --print          Only print the submit script (implies --nosubmit)
ADV     --nosubmit       Do submit the script, only create it (useful with --submit)
ADV     --submit   FILE  Submit the script FILE
ADV -r, --resubmit FILE  Resub the script if exit status was 0 and FILE not exist
ADV -w, --wait           Waits for the job to finish
ADV                      Exit status from existence of FILE from --finish or --resubmit
ADV     --sleeptime      Changes the sleeptime for --wait
ADV                      Default: $sleeptime
ADV     --shell NAME     Change the shell to use, script will sources ~/.XXXrc
ADV                      Default: $myshell
ADV     --source FILE    Source this file before run the progam
ADV     --scratch        Use scratch on "$scratch_dir/\$USER/"
ADV     --needed FILES   Give the files needed to be copy to the scratch dir to
ADV                      run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
ADV                      (implies --scratch)
ADV     --cpback FILE    Copy back files from scratch from the job, which was start with FILE
ADV                      and remove the dir afterwards (useful after crash)

    QUEUE OPTIONS:
    -N                   Number of cpus (also determines the queue together with walltime)
                         Possible: 1|2|8
                         Default: $ncpus
ADV     --nompi          This is NOT a mpi job, so do NOT add mpirun (or equivalent)
ADV                      to the command line (automatic for ncpus = 1)
        --walltime TIME  Change wall clock time (use 1cpu and  00:20:00 for test queue)
                         Default: $wall_time
ADV     --runat HOST     Specify the host to run yourself
ADV     --runatnow HOST  like --runat, but one do it one time, not after the resubmitting
ADV     --queue  NAME.q  Overwrite the queue to be used with NAME.q
ADV                      (also in the case of --queueinfo)
ADV     --nooldnodes     Only use host >=thop63


    JOBS OPTIONS:
        --showjobs        Show my jobs running (on $submit_host)
        --alljobs         Show all jobs running (on $submit_host)
ADV     --checkjob JOB_ID Return true if job is still running (useful with -f)
ADV                       "while ${0##*/} -q --checkjob JOB_ID; do :; done"
ADV     --pcheck PATTERN  Return true if at least one job matching a pattern is still running
ADV                       PATTERN is search in the name column (useful with -f)
ADV                       "while ${0##*/} -q --pcheck NAME; do :; done"
        --showlog  JOB_ID Show logfile for running job with number JOB_ID
ADV     --showdir  JOB_ID Show pwd of simulation
ADV     --taillog  JOB_ID Same as --showlog but tail and follow
        --killjob  JOB_ID Kill job with number JOB_ID
ADV     --statjob  JOB_ID Show status of the job with number JOB_ID
ADV     --pkill PATTERN   Kill all jobs matching a pattern
ADV     --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
        --queueinfo [NR]  Show info about some queue [1|2|8] or all queues
ADV     --header          Show info header

    COMMON OPTIONS:
ADV     --                 End of options (if program starts with -)
ADV -q, --quiet            Be quiet
        --rcfile FILE      Extra setting file with defaults to read
                           Default: read only $rcfile if exist
ADV     --showdefaults     Show the default settings before reading $rcfile and the
ADV                        file given by --rcfile, useful to create own rcfile with:
ADV                        "${0##*/} --showdefaults > $rcfile"
ADV     --ignore-obsolete  Do not stop if ${0##*/} is obsolete
ADV -v, --version          Prints version
        --selfupdate       Do a self update from googlecode
    -h, --help             Show short help message
        --longhelp         Show long help message

ADV Notes for usage of scratch space:
ADV ------------------------
ADV -The usage of the scratch space is complicated, use it with care!
ADV -Only use scratch space if you expect heavy input/output load
ADV -You may add the input files to copy to the scratch dir  with --needed
ADV  or use "--needed '*'", if want to copy all files of the current dir.
ADV -If the binary in not in your PATH, give the full path of binary or
ADV  add itself to --needed itself and use "./"
ADV -Remember, copying input files to the scratch dir and output file back here
ADV  takes time, so substract time needed for that from the wall of the actual simulation!

ADV Note for script variables:
ADV --------------------------
ADV The following variables are available in the batch script and can be used
ADV - npcu = Number of used cpus
ADV - walltime = Walltime in the format XX:XX:XX
ADV - wallsecs = Walltime in seconds
ADV - wallhours = Walltime in hours

    Examples:
       ${0##*/} -8p sleep 30
       ${0##*/} -8p --nompi mpirun -np 8 sleep 30
       ${0##*/} --name gromacs mdrun -v
       ${0##*/} -8 --needed topol.tpr mdrun_mpi
       ${0##*/} echo -e 'SOL\\\\nSOL' \| g_rdf -b 100 -n index.ndx
       ${0##*/} -8 --source ~/myGromacs/GMXRC --resubmit confout.gro  mdrun_mpi -append -cpi state.cpt -maxh \\\$wallhours
                (Note: -cpi is smart, the first time mdrun will start normal!)
       ${0##*/} -8 --needed '*' --resubmit confout.gro  mdrun_mpi -append -cpi state.cpt -maxh \\\$wallhours
                (Note: --needed '*' needs a separate dir for the simulation!)

    Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_logs() {
  local message path logfile
  [ -z "$2" ] && die "show_logs: Missing argument"
  number_check "$1" "--showlog/--taillog"
  message=$(run_on_host "$job_status -r -j $1") || die
  path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
  logfile=$(echo -e "$message" | awk '/^stdout_path_list:/{ print $2}')
  $2 $path/$logfile
  return $?
}

show_path() {
  local message path
  [ -z "$1" ] && die "show_path: Missing argument"
  number_check "$1" "--showdir"
  message=$(run_on_host "$job_status -r -j $1") || die
  path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
  [ -z "$path" ] && die "show_path: Could not get path"
  echo "$path"
  return $?
}

copy_back() {
  local path logfile host
  [ -z "$1" ] && die "copy_back: Missing argument"
  [ -f "$1" ] || die "copy_back: Could not found $1"
  [ -z "$(grep -e "${0##*/}" $1)" ] && die "$1 seems NOT to be a '${0##*/}' script"
  logfile=$(sed -n 's/^#$ -o //p' $1) || die "copy_back: could not get logfile"
  [ -f "${logfile}" ] || die "copy_back: logfile '$logfile' not found"
  host="$(sed -n 's/^Hi, I am job [0-9]* on \(.*\) in .*$/\1/p' "$logfile")"
  [ -z "$host" ] && die "copy_back: Could not get hostname for logfile '$logfile'"
  path="$(sed -n 's/^Starting simulation in \(.*\)$/\1/p' "$logfile")"
  [ -z "$path" ] && die "copy_back: Could not get path for logfile '$logfile'"
  echo Copying back data from $host:$path/ to .
  scp -Cpr "$host:$path/*" . || die "scp -Cr $host:$path/* . failed"
  echo Removing $path on $host
  ssh $host "rm -rf $path" || die "ssh $host rm -rf $path failed"
  return $?
}

get_path_from_script(){
  local path
  [ -z "$1" ] && die "get_path_from_script: Missing argument"
  [ -f "$1" ] || die "get_path_from_script: Could not found"
  [ -z "$(grep -e "${0##*/}" $1)" ] && die "$1 seems NOT to be a '${0##*/}' script"
  path="$(awk '/^cd/{print $2;exit 0}' $1)"
  [ -z "$path" ] && die "get_path_from_script: found not grep path from $1"
  echo "$path"
}

if [ -z "$(type -p mktemp)" ]; then
  mktemp() {
    [[ $1 = "-u" ]] && shift
    [[ -z $1 ]] && die "mktemp: missing argument"
    [[ -z ${1##*X} ]] || die "mktemp: argument has to end at least with X"
    local end trunc i l tmp newend
    end=${1##*[^X]}
    trunc=${1%${end}}
    l=${end//[^X]}
    l=${#l}
    while true; do
      newend="$end"
      for ((i=0;i<$l;i++)); do
        newend="${newend/X/${RANDOM:0:1}}"
      done
      tmp="${trunc}${newend}"
      [[ -f $tmp ]] || break
    done
    echo "$tmp"
  }
  export -f mktemp
fi

################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
done

if [ -f ${rcfile/\~/$HOME} ]; then
  source ${rcfile/\~/$HOME} || die "Error when sourcing $rcfile, correct it or remove it"
  qecho "I have sourced $rcfile"
fi

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  --rcfile )
   rcfile="$2"
   source $rcfile || die "Error when sourcing $rcfile, correct it or remove it"
   qecho "I have source $rcfile"
   shift 2;;
  --showdefaults )
   sed -ne '/^#BEGIN DEFAULTS/,/^#END DEFAULTS/p' $0 | sed -e '1d' -e '$d' -e '/^[^#]/s/^/#/'
   exit 0;;
  --ignore-obsolete )
   ignore_obsolete="yes"
   shift;;
  -[0-9] )
   ncpus=${1#-}
   number_check "$ncpus" "$1"
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   submit="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpi_job="no"
   shift ;;
   --nosubmit | --norun)
   submit="no"
   shift ;;
   --submit)
   direct_submit="yes"
   submit_job "$2"
   exit $? ;;
   --template )
   template="$2"
   shift 2;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --scratch )
   scratch="yes"
   shift ;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -r | --resub | --resubmit)
   resubmit_file="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2 ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun | --nompi)
   mpi_job="no"
   shift ;;
   --walltime )
   wall_time="$2"
   [ -z "${wall_time/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]}" ] || die "Wall clock time should have the format HH:MM:SS"
   shift 2;;
   --runat )
   hostname="$2"
   shift 2;;
   --runatnow )
   submit_opts="$submit_opts -l hostame=$2"
   shift 2;;
   --nooldnodes )
   no_old_nodes="yes"
   shift ;;
   --queue )
   specialq="$2"
   shift 2;;
   --showjobs )
   run_on_host "$job_status -u $USER"
   exit $?;;
   --alljobs )
   run_on_host "$job_status"
   exit $?;;
   --cpback )
   copy_back $2
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --statjob )
   stat_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   queue_info $2
   exit $?;;
   --showdir )
   show_path "$2"
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tailf"
   exit $?;;
  -v | --version)
   echo "${0##*/}, version $(get_version $0) ($branch branch) by C. Junghans"
   exit 0;;
  --selfupdate)
   self_update
   exit $?;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp | sed -e '/^ADV /d' -e 's/^    //'
   exit 0;;
  --longhelp)
   showhelp | sed -e 's/^ADV/   /' -e 's/^    //'
   exit 0;;
  --)
   shift
   break;;
  *)
   die "Unknown option '$1'";;
 esac
done

if version_check -q; then
  x=${0##*/}; x=${x//?/#}; y=${x//?/ }
  echo "##################################$x"
  echo "# Your version of ${0##*/} is obsolete ! #"
  echo "# Please run '${0##*/} --selfupdate' or  #"
  echo "# use '--ignore-obsolete' option ${y}#"
  echo "##################################$x"
  unset x y
  [[ $ignore_obsolete = "yes" ]] || die
fi

if [[ -n $(type -p sha1sum) ]] && [[ $(${0##*/} --showdefaults | sha1sum) != "ba93e1b971e3346e2cc989942c6245ef0f8b9cb8  -" ]]; then
  x=${0##*/}; x=${x//?/#}; y=${x//?/ }
  echo "###########################################$x$x"
  echo "# You have modified ${0##*/} internal settings !  $y#"
  echo "# Please do not do that as '${0##*/} --selfupdate'$y#"
  echo "# will overwrite them. Just run:          $y$y#"
  echo "# '${0##*/} --showdefaults > $rcfile'               #"
  echo "# and modify $rcfile                        $y#"
  echo "###########################################$x$x"
  unset x y
fi

if [ -z "$1" ]; then
  [ -z "${default_opts}" ] && die "Missing program name (try --help)"
  set -- ${default_opts}
fi

[[ $auto = "yes" ]] && name=${1##*/}

if [ -z "$batchname" ]; then
  #template contains no 'X'
  if [ -z "${template//[^X]}" ]; then
    batchname="${name}"
  else
    batchname=$(mktemp -u ${name}${template}) || die "mktemp could not generate file"
  fi
  touch ${batchname}
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="$name.log"
  else
    logfile="$batchname.log"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "submit script: $batchname"
  qecho "logfile: $logfile"
fi

if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ]; then
  echo "#! /bin/bash" > $batchname
elif [ "$myshell" = "zsh" ]; then
  echo "#! /usr/bin/zsh" > $batchname
elif [ "$myshell" = "tcsh" ]; then
  echo "#! /bin/tcsh" > $batchname
  set="set "
else
  die "Unsupported shell"
fi

queue_name="$(cpunr_to_queuename $ncpus)" || die

cat <<EOF >> $batchname
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using ${0##*/}, version $(get_version $0)

#sge options
#$ -cwd
#$ -j y
#$ -o $logfile
#$ -l h_rt=${wall_time}
#$ -q ${queue_name}
EOF

[ -n "$(extra_queue_header $ncpus)" ] && extra_queue_header $ncpus >> $batchname
[ -n "$hostname" ] && echo "#$ -l hostname=${hostname}" >> $batchname

#To mail or not to mail
if [ -z "$mail" ] || [ "$mail" = "none" ]; then
  echo "#$ -m n" >> $batchname
else
  echo "#$ -m e" >> $batchname
  [ "$mail" = "auto" ] && mail="${USER}@mpip-mainz.mpg.de"
  echo "#$ -M $mail" >> $batchname
fi

if [ "$myshell" = "bash" ]; then
  echo "#$ -S /bin/bash" >> $batchname
  [ -f ~/.bashrc ] && sh_source="source ~/.bashrc"
elif [ "$myshell" = "zsh" ]; then
  echo "#$ -S /usr/bin/zsh" >> $batchname
  [ -f ~/.zshrc ] && sh_source="source ~/.zshrc"
elif [ "$myshell" = "tcsh" ]; then
  echo "#$ -S /bin/tcsh" >> $batchname
  if [ -f ~/.tcshrc ]; then
    sh_source="source ~/.tcshrc"
  elif [ -f ~/.cshrc ]; then
    sh_source="source ~/.cshrc"
  fi
elif [ "$myshell" = "none" ]; then
  echo "#$ -S /bin/bash" >> $batchname
fi

cat <<EOF >>$batchname

${sh_source}

#BEGIN useful script variables
${set}walltime=${wall_time}
${set}wallsecs=$(walltime_to_sec ${wall_time})
${set}wallhours=$(( $(walltime_to_sec ${wall_time}) / 3600 ))
${set}ncpus=${ncpus}
#END useful script variables

cd $PWD
echo Hi, I am job \$JOB_ID on \$HOSTNAME in \$PWD

EOF
if [ -n "$extra_source" ]; then
  $(source $extra_source) || die "sourcing of file after --source failed, please check again"
  echo "source $extra_source" >> $batchname
fi
if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname
#Copy the needed files
${set}olddir=\$PWD
${set}newdir=$scratch_dir/\$USER/\$JOB_ID
mkdir -p \$newdir || exit 1
EOF
[ -n "$filelist" ] && cat <<EOF >>$batchname
echo Copy needed files:
echo $filelist
cp -r $filelist \$newdir
echo finished copying files
EOF
echo 'cd $newdir' >> $batchname
fi

if [ -n "${extra_begin_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra begin code
${extra_begin_code}
#END of extra begin code
EOF
fi

echo echo Starting simulation in \$PWD >> $batchname

[[ "$time" = "yes" ]] && echo date >> $batchname
[[ $ncpus -ne 1 ]] && echo "pgrep lamd > /dev/null || $lamboot_cmd" >> $batchname
if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname
  done
  cmdline=""
else
  #do not add quotes to the first argument
  cmdline="$1"
  shift
  for i in "$@"; do
    [ -z "${i//*[[:space:]]*}" ] && cmdline="${cmdline} '$i'" || cmdline="${cmdline} $i"
  done
  if [ "$mpi_job" = "yes" ] && [ $ncpus -gt 1 ]; then
    cmdline="$mpirun_cmd -np $ncpus $cmdline"
  fi
fi

cat <<EOF >>$batchname
$cmdline
${set}result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

if [ -n "${extra_end_code}" ]; then
  cat <<EOF >>$batchname
#BEGIN of extra end code
${extra_end_code}
#END of extra end code
EOF
fi

if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname

#Copy files back
echo Copy back files:
echo *
cp -ru * \$olddir
echo finished copying files
cd \$olddir
[ \$result -eq 0 ] && echo Removing scratch dir
[ \$result -eq 0 ] && rm -fr \$newdir
EOF
fi

[[ "$time" = "yes" ]] && echo date >> $batchname

if [ -n "$resubmit_file" ]; then
  [ -f "$resubmit_file" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $job_submit in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f '$resubmit_file' ] && $job_submit $PWD/$batchname" >> $batchname
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && [ -f $resubmit_file ] && touch $finish_file" >> $batchname
else
  [ -z "$finish_file" ] || echo "[ \$result -eq 0 ] && touch '$finish_file'" >> $batchname
fi

if [ "$submit" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && qecho "to submit the script run: '${0##*/} --submit $batchname'"
  exit 0
fi

submit_job $batchname

if [ "$wait" = "yes" ]; then
  qecho "Waiting for $batchname to finish"
  quiet="yes"
  while pcheck_job $batchname; do
    sleep $sleeptime;
  done
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resubmit_file}" ]] && [[ ! -f "$resubmit_file" ]] && exit 1
  exit 0
fi
