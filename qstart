#! /bin/bash

#version 0.1   ,29.09.08 -- initial version
#version 0.2   ,29.09.08 -- added scratch option
#version 0.3   ,30.09.08 -- added template options
#version 0.4   ,02.10.08 -- added job options
#version 0.4.1 ,02.10.08 -- bugs fix in exit code
#version 0.4.2 ,02.10.08 -- added --queueinfo
#version 0.4.3 ,05.10.08 -- bug in checkjob with zero msg
#version 0.5.0 ,07.10.08 -- consitency with start
#version 0.5.1 ,08.10.08 -- notemplate is now emptytemplate
#version 0.5.2 ,08.10.08 -- corrected help
#version 0.5.3 ,08.10.08 -- bug in short opts

#defaults
usage="${0##*/} [OPTIONS] COMMAND [options]"
qsubmit="qsubmit"
mpirun="yes"
mpicmd="/opt/lam/bin/mpirun"
sge_path="/opt/SGE/bin/lx26-amd64"
qsub="$sge_path/qsub"
qstat="$sge_path/qstat"
qdel="$sge_path/qdel"
runhost="thop02"
ncpus=1
name="q"
quiet="no"
auto="no"
run="yes"
batchname=""
logfile=""
finish_file=""
time="no"
scratch_dir="/usr/scratch"
scratch="no"
template="_XXXXX"
mail="$USER@mpip-mainz.mpg.de"

check_job() {
message=$(ssh $runhost "export SGE_ROOT=/opt/SGE;$qstat -u $USER")
[[ $? -eq 0 ]] || exit 1
if [ -z "$(echo -e "$message" | awk "(\$1==$1){print \$0}")" ]; then
   [[ "$quiet" = "yes" ]] || echo Job \"$1\" on $runhost NOT found
   exit 1
else
   [[ "$quiet" = "yes" ]] || echo Job \"$1\" on $runhost found
   exit 0
fi
}

kill_job() {
ssh $runhost "export SGE_ROOT=/opt/SGE;$qdel $1"
[[ $? -eq 0 ]] || exit 1
}

pkill_job() {
if [ -z "$1" ]; then
   echo Expect a pattern
   exit 1
fi
message=$(ssh $runhost "export SGE_ROOT=/opt/SGE;$qstat -u $USER")
[[ $? -eq 0 ]] || exit 1
for job_id in $(echo -e "$message" | perl -nae "print \"\$F[0]\n\" if (\$F[2] =~ /$1/)"); do
   echo $0 --killjob $job_id
done
}

number_check(){
number="$1"
option="$2"
if [ -z "$number" ] || [ -n "${number//[0-9]}" ]; then
   echo argument after $option should be a number
   exit 1
fi
}

queue_info() {
if [ $1 -eq 1 ]; then
   queue="all.q"
elif [ $1 -eq 2 ]; then
   queue="dual.q"
elif [ $1 -eq 8 ]; then
   queue="octal.q"
else
   echo Number of cpus unsupported >&2
   exit 1
fi
ssh $runhost "export SGE_ROOT=/opt/SGE;$qstat -q $queue"
[[ $? -eq 0 ]] || exit 1
}

showhelp() {
 cat << eoh
A script to start a job on the cluster.
It builds a very simple qsub script (see -p options) and
run it.

$usage

SCRIPT OPTIONS:
-n, --name NAME      Change global name of script
                     Default: $name
    --batch NAME     Change name of the qsub script
                     Default:  \$(mktemp ${name}$template)
                     (Argument is NAME+TEMPLATE)
-l, --log NAME       Change name of the output file
                     Default: log_"batchname"
    --template TEXT  Change template for mktemp
                     Default: $template
-a, --auto           Use first argument as global name
-e, --emptytemplate  Same as --template ""
-m, --mail NAME      send mail to NAME
                     default: '$mail'
-x, --nomail         will not use mail function
-f, --finish NAME    Create a file NAME when succesfully finished
                     Usefull with --checkjob and "[[ -f NAME ]] || exit 1"
-t, --time           Adds a date command before and after the command
-p, --print          Only print the qsub script (implies --norun)
    --norun          Do NOT run the qsub script in the end

    --scratch        Use scratch on "$scratch_dir/\$USER/" (EXPERIMENTAL)
    --needed FILES   Give the files needed to be copy to the scratch dir to
                     run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
                     (implies --scratch)

MPI OPTIONS:
-N                   Number of cpus (also determines the queue)
                     Default: $ncpus
    --nompirun       Do NOT add mpirun automatically to the command line for ncpus > 0


JOBS OPTIONS:
    --showjobs        Show jobs running (on $runhost)
    --checkjob JOB_ID Return true if job is still running (useful with --follow)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --taillog  JOB_ID Same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with NUMBER
    --pkill PATTERN   Kill all jobs matching a pattern
    --queueinfo NR    Show info about some queue [1|2|8]

COMMON OPTIONS:
-q, --quiet          Be quiet
-v, --version        Prints version
-h, --help           Show this help message

The usage of the scratch space is still experimental!!!
You may add the files to copy there with --needed.
Give full path of binary or add itself to --needed and use "./".

Examples:
   ${0##*/} -8p sleep 30
   ${0##*/} -8p --nompirun mpirun -np 8 sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} -8 --needed traj.trr mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_jobs() {
ssh $runhost "export SGE_ROOT=/opt/SGE;$qstat -u $USER"
[[ $? -eq 0 ]] || exit 1
}

show_logs() {
message=$(ssh $runhost "export SGE_ROOT=/opt/SGE;$qstat -r -j $1")
[[ $? -eq 0 ]] || exit 1
path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
logfile=$(echo -e "$message" | awk '/^stdout_path_list:/{ print $2}')
$2 $path/$logfile
}
################################################
############## Main Program ####################
################################################
shopt -s extglob

while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmf]}" != "${1}" ]; then
       set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
       set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  -[0-9] )
   ncpus=${1#-}
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   run="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
   --norun )
   run="no"
   shift ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --scratch )
   scratch="yes"
   shift ;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -x | --nomail)
   mail=''
   shift ;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --nompirun )
   mpirun="no"
   shift ;;
   --showjobs )
   show_jobs
   exit 0;;
   --killjob )
   number_check "$2" "--killjob"
   kill_job $2
   exit 0;;
   --pkill )
   pkill_job "$2"
   exit 0;;
   --checkjob )
   number_check "$2" "--checkjob"
   check_job $2
   exit 0;;
   --queueinfo )
   number_check "$2" "--queueinfo"
   queue_info $2
   exit 0;;
   --showlog )
   number_check "$2" "--showlog"
   show_logs "$2" "cat"
   exit 0;;
   --taillog )
   number_check "$2" "--showlog"
   show_logs "$2" "tailf"
   exit 0;;
  -v | --version)
   echo ${0##*/}, $(sed -ne 's/^#\(version.*\) -- .*$/\1/p' $0 | sed -n '$p') by C. Junghans
   exit 0;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  *)
   echo Unknown option \'$1\' >&2
   exit 1;;
 esac
done

if [ -z "$1" ]; then
  echo Missing program name
  echo $usage
  echo help with --help
  exit 1
fi

[[ $auto = "yes" ]] && template=$1

if [ "$mpirun" = "no" ] || [ $ncpus -eq 1 ]; then
   cmdline="$*"
else
   cmdline="$mpicmd -np $ncpus $*"
fi

if [ -z "$batchname" ]; then
   if [ -n $(type -p mktemp) ]; then
      batchname=$(mktemp ${name}${template}) || { echo mktemp could not generate file >&2; exit 1; }
   else
      echo No mktemp found >&2
      batchname=$name
   fi
fi

if [ -z "$logfile" ]; then
   if [ "$batchname" = "/dev/stdout" ]; then
      logfile="log_$name"
   else
      logfile="log_$batchname"
   fi
fi

if [ "$quiet" = "no" ] && [ "$batchname" != "/dev/stdout" ]; then
   echo qsubscript: $batchname
   echo logfile: $logfile
fi

echo \#! /bin/bash >> $batchname
if [ $ncpus -eq 1 ]; then
   echo \#$ -q all.q >> $batchname
elif [ $ncpus -eq 2 ]; then
   echo \#$ -q dual.q >> $batchname
   echo \#$ -pe lammpi2cores 2 >> $batchname
elif [ $ncpus -eq 8 ]; then
   echo \#$ -q octal.q >> $batchname
   echo \#$ -pe lammpi8cores 8 >> $batchname
else
   echo Number of cpus unsupported >&2
   [[ "$batchname" = "/dev/stdout" ]] || rm $batchname
   exit 1
fi

if [ -z "$mail" ]; then
   echo \#$ -m n >> $batchname
else
   echo \#$ -m e >> $batchname
   echo \#$ -M $mail >> $batchname
fi

cat <<EOF >>$batchname
#$ -cwd
#$ -j y
#$ -o $logfile

source ~/.bashrc

cd $PWD
echo I am job \$JOB_ID on \$HOSTNAME
EOF

if [ "$scratch" = "yes" ]; then
   [[ "$time" = "yes" ]] && echo date >> $batchname
   cat <<EOF >>$batchname
olddir=\$PWD
echo Copy needed files:
echo $filelist
newdir=$scratch_dir/\$USER/\$JOB_ID
mkdir -p \$newdir
for myfile in $filelist; do
   cp \$myfile \$newdir
done
echo finished copying files
cd \$newdir
EOF
fi

echo echo Starting simulation >> $batchname
[[ "$time" = "yes" ]] && echo date >> $batchname
echo $cmdline >> $batchname
echo result=\$? >> $batchname

if [ "$scratch" = "yes" ]; then
   [[ "$time" = "yes" ]] && echo date >> $batchname
   cat <<EOF >>$batchname
echo Copy back files:
ls
cp -u * \$olddir
echo finished copying files
echo Removing scratch dir
[[ \$result -eq 0 ]] && rm -fr \$newdir
EOF
fi
[[ "$time" = "yes" ]] && echo date >> $batchname
[[ -z "$finish_file" ]] || echo "[[ \$result -eq 0 ]] && touch $finish_file" >> $batchname

if [ "$run" = "yes" ]; then
   ssh $runhost "export SGE_ROOT=/opt/SGE;cd $PWD;$qsub $batchname"
   [[ $? -eq 0 ]] || { echo Failed >&2; exit 1; }
else
   echo "ssh $runhost \"export SGE_ROOT=/opt/SGE;cd $PWD;$qsub $batchname\""
fi
