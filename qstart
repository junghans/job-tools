#! /bin/bash

#version 0.1   ,29.09.08 -- initial version
#version 0.2   ,29.09.08 -- added scratch option
#version 0.3   ,30.09.08 -- added template options
#version 0.4   ,02.10.08 -- added job options
#version 0.4.1 ,02.10.08 -- bugs fix in exit code
#version 0.4.2 ,02.10.08 -- added --queueinfo
#version 0.4.3 ,05.10.08 -- bug in checkjob with zero msg
#version 0.5.0 ,07.10.08 -- consitency with start
#version 0.5.1 ,08.10.08 -- notemplate is now emptytemplate
#version 0.5.2 ,08.10.08 -- corrected help
#version 0.5.3 ,08.10.08 -- bug in short opts
#version 0.5.4 ,08.10.08 -- added --header
#version 0.5.5 ,11.11.08 -- fixed bug with --print
#version 0.5.6 ,17.11.08 -- added --pcheck
#version 0.5.7 ,17.11.08 -- added --resub
#version 0.5.8 ,21.11.08 -- added resub example
#version 0.5.9 ,02.12.08 -- remove perl depend, cut patterns to 8 chars
#version 0.5.10,26.02.09 -- added some note and --shell option
#version 0.6.0, 02.03.09 -- --scratch should work now
#version 0.6.1, 07.04.09 -- make it work with tcsh + bugfix in pe for 2cpus
#version 0.6.2, 14.05.09 -- added zsh support, thx to Konstantin
#version 0.7.0, 14.05.09 -- added --wait
#version 0.7.1, 24.08.09 -- added --runat option
#version 0.7.2, 24.08.09 -- --(p)checkjob will mention jobs in error state
#version 0.7.3, 26.08.09 -- improved shell related stuff
#version 0.7.4, 02.09.09 -- fixed small bug in --auto, added --runatnow
#version 0.7.5, 14.09.09 -- add header in batch script
#version 0.8.0, 18.09.09 -- tcsh support and --script option
#version 0.8.1, 21.09.09 -- solved a tcsh issue (thx to biswa)
#version 0.8.2, 24.09.09 -- solved another tcsh issue (thx to biswa)
#version 0.8.3, 02.10.09 -- moved to thop100, added --getjid and clean up
#version 0.8.4, 02.11.09 -- fixed a bug in --pcheck
#version 0.8.5, 03.11.09 -- fixed another bug in --pcheck + pcheck help
#version 0.8.6, 24.11.09 -- added --showdir + better output in logfile
#version 0.8.7, 07.12.09 -- exec lamboot if no lamd is running 
#version 0.8.8, 04.01.10 -- add -- option 
#version 0.9.0, 06.01.10 -- fixed a bug in emptyfile list (thx to sasha) 
#version 0.9.1, 07.01.10 -- clean up, added run_on_host
#version 0.9.2, 11.01.10 -- added --source option + cmdline in script
#version 0.9.3, 01.02.10 -- rm batchname, when crashing, resub warning
#version 0.9.4, 04.02.10 -- added some checks for .*shrc files + removed sh_cmd

#defaults
usage="${0##*/} [OPTIONS] COMMAND [options]"
qsubmit="qsubmit"
mpirun="yes"
hostname=""
qsub_opts=""
lamboot="/opt/lam/bin/lamboot"
mpicmd="/opt/lam/bin/mpirun"
sge_path="/opt/SGE/bin/lx26-amd64"
qsub="$sge_path/qsub"
qstat="$sge_path/qstat"
qdel="$sge_path/qdel"
runhost="thop100"
ncpus=1
name="q"
quiet="no"
auto="no"
run="yes"
batchname=""
logfile=""
finish_file=""
time="no"
scratch_dir="/usr/scratch"
scratch="no"
template="_XXXXX"
mail="$USER@mpip-mainz.mpg.de"
header="JOBS ON L.C.A.R.S. (thopXX)"
resub=""
myshell="${SHELL##*/}"
wait="no"
sleeptime=900
scriptmode="no"
extra_source=""
set=""

qecho() {
  [[ "$quiet" = "no" ]] && echo -e "$*"
}

die() {
  echo -e "$*" >&2
  [ -n "$batchname" ] && [ -f "$batchname" ] && rm -f "$batchname" && die "batchname $batchname removed"
  exit 1
}

run_on_host() {
  local message ssh
  [ "$1" = "--show" ] && { shift;ssh="echo "; }
  [ -z "$1" ] && die "run_on_host: Missing argument"
  if [ "$HOSTNAME" = "$runhost" ]; then
    ssh+="bash -c"
  else
    ssh+="ssh $runhost"
  fi
  message=$($ssh "$*" 2>&1) || die "$ssh '$*' failed\nError message: $message"
  echo -e "$message"
}

check_job() {
  local message
  number_check "$1" "--checkjob"
  message=$(run_on_host "$qstat -u $USER") || die
  if [ -z "$(echo -e "$message" | awk "(\$1==$1){print \$0}")" ]; then
    qecho "Job '$1' on $runhost NOT found"
    return 1
  elif [ -z "$(echo -e "$message" | awk "(\$1==$1)&&(\$5 !~ /E/){print \$0}")" ]; then
    qecho "Job '$1' on $runhost in error state"
    return 1
  else
    qecho "Job '$1' on $runhost found"
    return 0
  fi
}

pcheck_job() {
  local job_id myjobs failed
  [ -n "$1" ] || die "pcheck_job: No pattern given"
  myjobs="$(print_jobids $1)" || die
  if [ -z "$myjobs" ]; then 
    qecho "No jobs matching $1 found" 
    return 1
  fi
  failed="yes"
  for job_id in $myjobs; do
    check_job $job_id && failed="no"
  done
  [ "$failed" = "yes" ] && return 1
  return 0
}

kill_job() {
  number_check "$1" "--killjob"
  run_on_host "$qdel $1"
  return $?
}

print_jobids() {
  local message job_id
  [ -n "$1" ] || die "print_jobids: Expect a pattern"
  message=$(run_on_host "$qstat -u $USER") || die
  for job_id in $(echo -e "$message" | awk "(\$3 ~ /${1:0:8}/){print \$1}"); do
    echo $job_id
  done
}

pkill_job() {
  local job_id failed myjobs
  [ -n "$1" ] || die "pkill_job: Expect a pattern"
  myjobs="$(print_jobids $1)" || die
  for job_id in $myjobs; do
    kill_job $job_id || failed="yes"
  done
  [ "$failed" = "yes" ] || return 1
  return 0
}

number_check(){
  local number option
  [ -z "$1" ] && die "number_check: Missing argument"
  number="$1"
  option="$2"
  [ -z "$number" ] && die "Missing number in $option"
  [ -n "${number//[0-9]}" ] && die "Argument after $option should be a number"
}

queue_info() {
  local queue
  number_check "$1" "--queueinfo"
  if [ $1 -eq 1 ]; then
    queue="all.q"
  elif [ $1 -eq 2 ]; then
    queue="dual.q"
  elif [ $1 -eq 8 ]; then
    queue="octal.q"
  else
    die "Number of cpus unsupported"
  fi
  run_on_host "$qstat -q $queue"
  return $? 
}

showhelp() {
 cat << eoh
A script to start a job on the cluster.
It builds a very simple qsub script (see -p options) and
run it.

$usage

SCRIPT OPTIONS:
-n, --name NAME      Change global name of script
                     Default: $name
    --batch NAME     Change name of the qsub script
                     Default:  \$(mktemp ${name}$template)
                     (Argument is NAME+TEMPLATE)
-l, --log NAME       Change name of the output file
                     Default: log_"batch"
    --template TEXT  Change template for mktemp
                     Default: $template
-a, --auto           Use first argument as name
    --script         Will use the argument as base scripts and concatenate them
                     (implies --nompirun)
-e, --emptytemplate  Same as --template ""
-m, --mail NAME      send mail to NAME
                     default: '$mail'
-x, --nomail         will not use mail function
-f, --finish NAME    Touches file NAME when succesfully finished
-t, --time           Adds a date command before and after the command
-p, --print          Only print the qsub script (implies --norun)
    --norun          Do NOT run the qsub script in the end
-r, --resub FILE     Resub the script if exit status was 0 and FILE not exist
-w, --wait           Waits for the job to finish
                     Exit status from existence of FILE from --finish or --resub
    --sleeptime      Changes the sleeptime for --wait
                     Default: $sleeptime
    --shell NAME     Change the shell to use, script will sources ~/.XXXrc   
                     Default: $myshell
    --source FILE    Source this file before run the progam
    --scratch        Use scratch on "$scratch_dir/\$USER/"
    --needed FILES   Give the files needed to be copy to the scratch dir to
                     run, remember to use quotes ("file1 file2 file3" or "\$(ls *.d)")
                     (implies --scratch)

MPI OPTIONS:
-N                   Number of cpus (also determines the queue)
                     Default: $ncpus
    --nompirun       Do NOT add mpirun automatically to the command line for ncpus > 1
    --runat HOST     Specify the host to run yourself
    --runatnow HOST  like --runat, but one do it one time, not after the resub


JOBS OPTIONS:
    --showjobs        Show jobs running (on $runhost)
    --checkjob JOB_ID Return true if job is still running (useful with --f)
                      "while ${0##*/} -q --checkjob JOB_ID; do :; done"
    --pcheck PATTERN  Return true if at least one job matching a pattern is still running
                      PATTERN is search in the name column (useful with --f)
                      "while ${0##*/} -q --pcheck NAME; do :; done"
    --showlog  JOB_ID Show logfile for running job with number JOB_ID
    --showdir  JOB_ID Show pwd of simulation
    --taillog  JOB_ID Same as --showlog but tail and follow
    --killjob  JOB_ID Kill job with NUMBER
    --pkill PATTERN   Kill all jobs matching a pattern
    --getjid PATTERN  Retrun the ids of all jobs matching PATTERN
    --queueinfo NR    Show info about some queue [1|2|8]
    --header          Show info header

COMMON OPTIONS:
    --               End of options (if program starts with -)
-q, --quiet          Be quiet
-v, --version        Prints version
-h, --help           Show this help message

Notes for scratch space :
------------------------
-The usage of the scratch space is still at the beginning of testing,
 use it with care! 
-You may add the files to copy there with --needed or use "--needed '*'",
 if your job has a separate dir.
-Give the full path of binary or add itself to --needed and use "./", if
 it is not in your PATH variable.
-Remember to subtract the time needed to copy the files !

Examples:
   ${0##*/} -8p sleep 30
   ${0##*/} -8p --nompirun mpirun -np 8 sleep 30
   ${0##*/} --name gromacs mdrun -v
   ${0##*/} -8 --needed topol.tpr mdrun
   ${0##*/} "echo -e \"SOL\nSOL\" | g_rdf -b 100 -n index.ndx"
   ${0##*/} -8 --resub confout.gro  mdrun -append -cpi state.cpt -maxh 36
            (Note: -cpi is smart, the first time mdrun will start normal!)         
   ${0##*/} -8 --needed '*' --resub confout.gro  mdrun -append -cpi state.cpt -maxh 35
            (Note: --needed '*' needs a separate dir for the simulation!)

Send comments and bugs to: junghans@mpip-mainz.mpg.de
eoh
}

show_jobs() {
  run_on_host "$qstat -u $USER"
  return $?
}

show_logs() {
  local message path logfile
  [ -z "$2" ] && die "show_logs: Missing argument"
  number_check "$1" "--showlog/--taillog"
  message=$(run_on_host "$qstat -r -j $1") || die
  path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
  logfile=$(echo -e "$message" | awk '/^stdout_path_list:/{ print $2}')
  $2 $path/$logfile
  return $?
}

show_path() {
  local message path
  [ -z "$1" ] && die "show_path: Missing argument"
  number_check "$1" "--showdir"
  message=$(run_on_host "$qstat -r -j $1") || die
  path=$(echo -e "$message" | awk '/^cwd/{ print $2}')
  [ -z "$path" ] && die "show_path: Could not get path"
  echo "$path"
  return $?
}

################################################
############## Main Program ####################
################################################
shopt -s extglob

cmdline="${0##*/}"
for i in "$@"; do
  cmdline+=" '$i'"
done
while [ "${1#-}" != "$1" ]; do
  if [ "${1#--}" = "$1" ] && [ -n "${1:2}" ]; then
    if [ "${1#-[nlmfr]}" != "${1}" ]; then
      set -- "${1:0:2}" "${1:2}" "${@:2}"
    else
      set -- "${1:0:2}" "-${1:2}" "${@:2}"
    fi
 fi
 case $1 in
  -[0-9] )
   ncpus=${1#-}
   shift;;
  -p | --print )
   batchname="/dev/stdout"
   run="no"
   shift;;
  -q | --quiet )
   quiet="yes"
   shift;;
   -l | --log )
   logfile="$2"
   shift 2;;
   --batch )
   batchname="$2"
   shift 2;;
   -n | --name )
   name="$2"
   shift 2;;
   -f | --finish )
   finish_file="$2"
   shift 2;;
   -a | --auto )
   auto="yes"
   shift ;;
  --script )
   scriptmode="yes"
   mpirun="no"
   shift ;;
   --norun )
   run="no"
   shift ;;
   -e | --emptytemplate )
   template=""
   shift ;;
   --scratch )
   scratch="yes"
   shift ;;
   --needed )
   filelist=$2
   scratch="yes"
   shift 2;;
   -t | --time )
   time="yes"
   shift ;;
   -x | --nomail)
   mail=''
   shift ;;
   -r | --resub)
   resub="$2"
   shift 2;;
   -w | --wait)
   wait="yes"
   shift 1;;
  --sleeptime)
   number_check "$2" "--sleeptime"
   sleeptime="$2"
   shift 2;;
  --header)
   echo $header
   exit 0;;
   -m | --mail)
   mail="$2"
   shift 2 ;;
   --shell)
   myshell="$2"
   shift 2 ;;
   --source)
   extra_source="$2"
   shift 2 ;;
   --nompirun )
   mpirun="no"
   shift ;;
   --runat )
   hostname="$2"
   shift 2;;
   --runatnow )
   qsub_opts="$qsub_opts -l hostame=$2"
   shift 2;;
   --showjobs )
   show_jobs
   exit $?;;
   --killjob )
   kill_job $2
   exit $?;;
   --getjid )
   print_jobids "$2"
   exit $?;;
   --pkill )
   pkill_job "$2"
   exit $?;;
   --checkjob )
   check_job $2
   exit $?;;
   --pcheck )
   pcheck_job $2
   exit $?;;
   --queueinfo )
   queue_info $2
   exit $?;;
   --showdir )
   show_path "$2"
   exit $?;;
   --showlog )
   show_logs "$2" "cat"
   exit $?;;
   --taillog )
   show_logs "$2" "tailf"
   exit $?;;
  -v | --version)
   echo ${0##*/}, $(sed -ne 's/^#\(version.*\) -- .*$/\1/p' $0 | sed -n '$p') by C. Junghans
   exit 0;;
  --hg)
   echo "${0##*/}: $(sed -ne 's/^#version.* -- \(.*\)$/\1/p' $0 | sed -n '$p')"
   exit 0;;
  -h | --help)
   showhelp
   exit 0;;
  --)
   shift
   break;;
  *)
   die "Unknown option '$1'"
   exit 1;;
 esac
done

[ -z "$1" ] && die "Missing program name (try --help)"

[[ $auto = "yes" ]] && name=${1##*/}

if [ -z "$batchname" ]; then
  if [ -n $(type -p mktemp) ]; then
    batchname=$(mktemp ${name}${template}) || die "mktemp could not generate file" 
  else
    echo No mktemp found >&2
    batchname=$name
  fi
fi

if [ -z "$logfile" ]; then
  if [ "$batchname" = "/dev/stdout" ]; then
    logfile="log_$name"
  else
    logfile="log_$batchname"
  fi
fi

if [ "$batchname" != "/dev/stdout" ]; then
  qecho "qsubscript: $batchname"
  qecho "logfile: $logfile"
fi

#TCSH changes go here
#first line, source, for loop?
if [ "$myshell" = "bash" ] || [ "$myshell" = "none" ]; then
  echo "#! /bin/bash" > $batchname
elif [ "$myshell" = "zsh" ]; then
  echo "#! /usr/bin/zsh" > $batchname
elif [ "$myshell" = "tcsh" ]; then
  echo "#! /bin/tcsh" > $batchname
  set="set "
else
  die "Unsupported shell"
fi
cat <<EOF >>$batchname
#This script is generated by $USER@$HOSTNAME
#on $(date)
#by the command "$cmdline"
#using $($0 --version)

#sge options
EOF
if [ $ncpus -eq 1 ]; then
  echo "#$ -q all.q" >> $batchname
elif [ $ncpus -eq 2 ]; then
  echo "#$ -q dual.q" >> $batchname
  echo "#$ -pe lammpi2cpu 2" >> $batchname
elif [ $ncpus -eq 8 ]; then
  echo "#$ -q octal.q" >> $batchname
  echo "#$ -pe lammpi8cores 8" >> $batchname
else
  die "Number of cpus unsupported"
fi

if [ -n "$hostname" ]; then
  echo "#$ -l hostname=${hostname}" >> $batchname
fi
  
if [ -z "$mail" ]; then
  echo "#$ -m n" >> $batchname
else
  echo "#$ -m e" >> $batchname
  echo "#$ -M $mail" >> $batchname
fi

cat <<EOF >>$batchname
#$ -cwd
#$ -j y
#$ -o $logfile

EOF

if [ "$myshell" = "bash" ]; then
  [ -f "~/.bashrc" ] && echo "source ~/.bashrc" >> $batchname
elif [ "$myshell" = "zsh" ]; then
  [ -f "~/.bashrc" ] && echo "source ~/.zshrc" >> $batchname
elif [ "$myshell" = "tcsh" ]; then
  if [ -f "~/.tcshrc" ]; then
    echo "source ~/.tcshrc" >> $batchname
  elif [ -f "~/.cshrc" ]; then
    echo "source ~/.tcshrc" >> $batchname
  fi
fi

cat <<EOF >>$batchname

cd $PWD
echo Hi, I am job \$JOB_ID on \$HOSTNAME in \$PWD

EOF
[ -n "$extra_source" ] && echo "source $extra_source" >> $batchname
if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname
#Copy the needed files 
${set}olddir=\$PWD
${set}newdir=$scratch_dir/\$USER/\$JOB_ID
mkdir -p \$newdir || exit 1
EOF
[ -n "$filelist" ] && cat <<EOF >>$batchname
echo Copy needed files:
echo $filelist
cp -r $filelist \$newdir
echo finished copying files
EOF
echo 'cd $newdir' >> $batchname
fi

echo echo Starting simulation >> $batchname
[[ "$time" = "yes" ]] && echo date >> $batchname
[[ $ncpus -ne 1 ]] && echo "pgrep lamd > /dev/null || $lamboot" >> $batchname
if [ "$scriptmode" = "yes" ]; then
  for i in $@; do
    [ -f "$i" ] || die "File '$i' not found"
    cat "$i" >> $batchname 
  done
elif [ "$mpirun" = "no" ] || [ $ncpus -eq 1 ]; then
  echo "$*" >> $batchname
else
  echo "$mpicmd -np $ncpus $*" >> $batchname
fi
cat <<EOF >>$batchname
${set}result=\$?
[ \$result -ne 0 ] && echo "\$JOB_ID finished unhappy!"
EOF

if [ "$scratch" = "yes" ]; then
  [[ "$time" = "yes" ]] && echo date >> $batchname
  cat <<EOF >>$batchname

#Copy files back  
echo Copy back files:
echo *
cp -ru * \$olddir
echo finished copying files
cd \$olddir
echo Removing scratch dir
[ \$result -eq 0 ] && rm -fr \$newdir
EOF
fi
[[ "$time" = "yes" ]] && echo date >> $batchname
if [ -n "$resub" ]; then
  [ -f "$resub" ] && die "Resub is already there, unlogical !"
  if [ "$batchname" = "/dev/stdout" ]; then
    echo Error: Resub and print options make no sense together >&2
    echo Error: Filename after $qsub in next line will be wrong !!! >&2
  fi
  echo "[ \$result -eq 0 ] && [ ! -f $resub ] && { $qsub $PWD/$batchname; exit 0; }" >> $batchname
fi
[[ -z "$finish_file" ]] || echo "[ \$result -eq 0 ] && touch $finish_file" >> $batchname

if [ "$run" = "no" ]; then
  [[ "$batchname" != "/dev/stdout" ]] && run_on_host --show "cd $PWD;$qsub $qsub_opts $batchname'"
  exit 0
fi

message="$(run_on_host "cd $PWD;$qsub $qsub_opts $batchname")" || die
qecho "$message"

if [ "$wait" = "yes" ]; then
  job_id="$(echo "${message}" | sed -n 's/^Your job \([0-9]*\) (".*$/\1/p')" 
  [[ -z "$job_id" ]] && die "Oh oh could not fetch job_id"
  qecho "Waiting for $batchname ($job_id) to finish"
  quiet="yes"
  while check_job $job_id; do
    sleep $sleeptime;
  done
  [[ -n "${finish_file}" ]] && [[ ! -f "$finish_file" ]] && exit 1
  [[ -n "${resub}" ]] && [[ ! -f "$resub" ]] && exit 1
  exit 0
fi
